<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.7.19 (475949)"/><meta name="author" content="林源"/><meta name="created" content="2019-06-19 06:33:15 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2019-06-19 06:39:38 +0000"/><title>光流可视化</title></head><body><div>1. 光流原理</div><div>光流分为稀疏光流和稠密光流，稀疏光流就是只计算图片中特定点的光流，而稠密光流则是每个像素都要计算光流。 </div><div>简单地说就是在连续图片序列中，从第t帧到第t+1帧，每个像素的运动速度和运动方向。 </div><div>比如第t帧的时候A点的位置是(x1, y1)，那么我们在第t+1帧的时候再找到A点，假如它的位置是(x2,y2)，即It(x1,y1)=It+1(x2,y2)=It+1(x1+ux,x1+uy)It(x1,y1)=It+1(x2,y2)=It+1(x1+ux,x1+uy), 那么我们t-&gt;t+1的光流即为:(ux,vy)(ux,vy)。所以给定一对图片(t -&gt; t-1)，就可以计算出这对图片之间的光流图，大小和两帧的图片相同。 </div><div>有了t-&gt;t+1的光流，我们可以利用t+1帧的图片和这个光流将t+1帧warp到t帧，得到t帧的图片。怎么计算呢？对于第t帧上的每个像素点It(x1,y1)It(x1,y1)，都有It(x1,y1)=It+1(x1+ux,x1+uy)It(x1,y1)=It+1(x1+ux,x1+uy)，直接在t+1帧上取出(x1+ux,x1+uy)(x1+ux,x1+uy)位置处的值就好，这个坐标极有可能是浮点数，双线性插值即可。 </div><div>想通过光流推测某一帧图片，只要计算该帧到已知帧的光流即可通过warp得到 </div><div>比如我们想通过光流增强特征，已知t-1，t-3的特征，想用它们增强当前帧t的特征，只需要计算t-&gt;t-1和t-&gt;t-3的光流，然后利用这两个光流就可以把t-1，t-3的特征warp到t了。</div><div>2. 光流可视化</div><div>光流场是图片中每个像素都有一个x方向和y方向的位移，所以在上面那些光流计算结束后得到的光流flow是个和原来图像大小相等的双通道图像。 </div><div><img src="%E5%85%89%E6%B5%81%E5%8F%AF%E8%A7%86%E5%8C%96.resources/964B4D57-28D6-4815-B6BF-000967B134DD.png" height="335" width="701"/></div><div>不同颜色表示不同的运动方向，深浅表示运动的速度。 </div><div /><div>讲x和y转为极坐标，夹角(actan2(y,x))代表方向，极径(x和y的平方和开根号)代表位移大小，刚好用一下hsv的图像表示。上图的光流可以看到，红色的人在往右边动，那个蓝色的东西在往左上动 </div><div><br/></div><div><img src="%E5%85%89%E6%B5%81%E5%8F%AF%E8%A7%86%E5%8C%96.resources/F45B1CC8-C00C-4303-ACEA-B21A64248CD9.png" height="150" width="150"/></div><div><br/></div><hr/><hr/><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>def viz_flow(flow):</div><div>    # 色调H：用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°,蓝色为240°</div><div>    # 饱和度S：取值范围为0.0～1.0</div><div>    # 亮度V：取值范围为0.0(黑色)～1.0(白色)</div><div>    h, w = flow.shape[:2]</div><div>    hsv = np.zeros((h, w, 3), np.uint8)</div><div>    mag, ang = cv2.cartToPolar(flow[...,0], flow[...,1])</div><div>    hsv[...,0] = ang*180/np.pi/2</div><div>    hsv[...,1] = cv2.normalize(mag,None,0,255,cv2.NORM_MINMAX)</div><div>    # flownet是将V赋值为255, 此函数遵循flownet，饱和度S代表像素位移的大小，亮度都为最大，便于观看</div><div>    # 也有的光流可视化讲s赋值为255，亮度代表像素位移的大小，整个图片会很暗，很少这样用</div><div>    hsv[...,2] = 255</div><div>    bgr = cv2.cvtColor(hsv,cv2.COLOR_HSV2BGR)</div><div>    return bgr</div></div><div><br/></div></body></html>