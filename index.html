<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Learning Journal</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ü§ñ</text></svg>">
    <!-- PDF.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- MathJax for LaTeX equations -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-dark.min.css" rel="stylesheet" media="(prefers-color-scheme: dark)" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --primary-color: #2563eb;
            --secondary-color: #1e40af;
            --accent-color: #3b82f6;
            --background-color: #ffffff;
            --surface-color: #f8fafc;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --border-color: #e2e8f0;
            --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        [data-theme="dark"] {
            --primary-color: #3b82f6;
            --secondary-color: #2563eb;
            --accent-color: #60a5fa;
            --background-color: #0f172a;
            --surface-color: #1e293b;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border-color: #334155;
            --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.3), 0 1px 2px -1px rgb(0 0 0 / 0.3);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3), 0 4px 6px -4px rgb(0 0 0 / 0.3);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--background-color);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        .app-container {
            display: flex;
            height: 100vh;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background-color: var(--surface-color);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 1000;
            box-shadow: var(--shadow);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary-color);
            text-decoration: none;
        }

        .search-container {
            position: relative;
            display: flex;
            align-items: center;
        }

        .search-input {
            width: 300px;
            padding: 8px 16px 8px 40px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--background-color);
            color: var(--text-primary);
            font-size: 14px;
            outline: none;
            transition: all 0.2s ease;
        }

        .search-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgb(59 130 246 / 0.1);
        }

        .search-icon {
            position: absolute;
            left: 12px;
            color: var(--text-secondary);
            pointer-events: none;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .theme-toggle {
            background: none;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            font-size: 18px;
            transition: background-color 0.2s ease;
        }

        .theme-toggle:hover {
            background-color: var(--border-color);
        }

        .mobile-menu-button {
            display: none;
            background: none;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            font-size: 18px;
        }

        /* Sidebar */
        .sidebar {
            width: 320px;
            background-color: var(--surface-color);
            border-right: 1px solid var(--border-color);
            margin-top: 60px;
            overflow-y: auto;
            height: calc(100vh - 60px);
            position: fixed;
            left: 0;
            z-index: 900;
            transition: transform 0.3s ease;
        }

        .sidebar.collapsed {
            transform: translateX(-100%);
        }

        .sidebar-content {
            padding: 20px;
        }

        .sidebar-section {
            margin-bottom: 24px;
        }

        .sidebar-section h3 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 12px;
        }

        .folder-item {
            margin-bottom: 8px;
        }

        .folder-header {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            user-select: none;
        }

        .folder-header:hover {
            background-color: var(--border-color);
        }

        .folder-header.active {
            background-color: var(--primary-color);
            color: white;
        }

        .folder-icon {
            margin-right: 8px;
            font-size: 16px;
            transition: transform 0.2s ease;
        }

        .folder-header.expanded .folder-icon {
            transform: rotate(90deg);
        }

        .folder-name {
            font-weight: 500;
            flex: 1;
        }

        .file-count {
            font-size: 12px;
            color: var(--text-secondary);
            background-color: var(--border-color);
            padding: 2px 6px;
            border-radius: 12px;
        }

        .file-list {
            margin-left: 24px;
            margin-top: 8px;
            display: none;
        }

        .file-list.expanded {
            display: block;
        }

        .file-item {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            margin-bottom: 2px;
        }

        .file-item:hover {
            background-color: var(--border-color);
        }

        .file-item.active {
            background-color: var(--accent-color);
            color: white;
        }

        .file-icon {
            margin-right: 8px;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .file-name {
            font-size: 14px;
            flex: 1;
        }

        .favorite-icon {
            margin-left: 8px;
            color: #f59e0b;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .file-item:hover .favorite-icon,
        .favorite-icon.active {
            opacity: 1;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            margin-left: 320px;
            margin-top: 60px;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 60px);
            transition: margin-left 0.3s ease;
        }

        .main-content.sidebar-collapsed {
            margin-left: 0;
        }

        .content-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--surface-color);
        }

        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .breadcrumb-separator {
            color: var(--text-secondary);
        }

        .content-title {
            font-size: 24px;
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .content-meta {
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 14px;
            color: var(--text-secondary);
            flex-wrap: wrap;
        }

        .content-meta .pdf-button {
            font-size: 12px;
            padding: 6px 10px;
        }

        .content-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            transition: opacity 0.2s ease;
        }

        .content-body.loading {
            opacity: 0.7;
        }

        .welcome-content {
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
            padding: 60px 20px;
        }

        .welcome-title {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 16px;
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .welcome-subtitle {
            font-size: 20px;
            color: var(--text-secondary);
            margin-bottom: 32px;
        }

        .welcome-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 32px;
        }

        .stat-card {
            background-color: var(--surface-color);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow);
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: var(--primary-color);
        }

        .stat-label {
            font-size: 14px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .recent-updates {
            margin: 32px 0;
        }

        .section-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .recent-files-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .recent-file-item {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .recent-file-item:hover {
            background: var(--accent-color);
            color: white;
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
        }

        .recent-file-content {
            flex: 1;
        }

        .recent-file-title {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 4px;
            text-align: left;
        }

        .recent-file-meta {
            font-size: 14px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .recent-file-item:hover .recent-file-meta {
            color: rgba(255, 255, 255, 0.8);
        }

        .recent-file-type {
            background: var(--primary-color);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .quick-access {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 32px;
        }

        .quick-access-item {
            background-color: var(--surface-color);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            color: inherit;
        }

        .quick-access-item:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
            border-color: var(--primary-color);
        }

        .quick-access-icon {
            font-size: 32px;
            margin-bottom: 12px;
        }

        .quick-access-title {
            font-weight: 600;
            margin-bottom: 8px;
        }

        .quick-access-desc {
            font-size: 14px;
            color: var(--text-secondary);
        }

        /* Markdown Content */
        .markdown-content {
            max-width: 800px;
            margin: 0 auto;
        }

        .markdown-content h1,
        .markdown-content h2,
        .markdown-content h3,
        .markdown-content h4,
        .markdown-content h5,
        .markdown-content h6 {
            margin: 24px 0 16px 0;
            color: var(--text-primary);
        }

        .markdown-content h1 {
            font-size: 32px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 8px;
        }

        .markdown-content h2 {
            font-size: 24px;
        }

        .markdown-content h3 {
            font-size: 20px;
        }

        .markdown-content p {
            margin: 16px 0;
            line-height: 1.7;
        }

        .markdown-content ul,
        .markdown-content ol {
            margin: 16px 0;
            padding-left: 24px;
        }

        .markdown-content li {
            margin: 8px 0;
        }

        .markdown-content a {
            color: var(--primary-color);
            text-decoration: none;
            cursor: pointer;
            border-bottom: 1px solid transparent;
            transition: all 0.2s ease;
        }

        .markdown-content a:hover {
            text-decoration: none;
            border-bottom: 1px solid var(--primary-color);
            background-color: rgba(59, 130, 246, 0.1);
            padding: 2px 4px;
            border-radius: 3px;
        }

        .markdown-content a:active {
            background-color: rgba(59, 130, 246, 0.2);
        }

        .markdown-content code {
            background-color: var(--surface-color);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'SF Mono', 'Monaco', 'Cascadia Code', 'Roboto Mono', monospace;
            font-size: 0.9em;
        }

        .markdown-content pre {
            background-color: var(--surface-color);
            padding: 16px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 16px 0;
            border: 1px solid var(--border-color);
        }

        .markdown-content pre code {
            background: none;
            padding: 0;
        }

        .markdown-content blockquote {
            border-left: 4px solid var(--primary-color);
            padding-left: 16px;
            margin: 16px 0;
            color: var(--text-secondary);
            font-style: italic;
        }

        .markdown-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 16px 0;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
            background-color: var(--background-color);
            font-size: 14px;
        }

        .markdown-content th,
        .markdown-content td {
            padding: 8px 12px;
            text-align: left;
            border-right: 1px solid var(--border-color);
            vertical-align: middle;
            line-height: 1.4;
        }

        .markdown-content th:last-child,
        .markdown-content td:last-child {
            border-right: none;
        }

        .markdown-content th {
            background-color: var(--surface-color);
            font-weight: 600;
            font-size: 13px;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-color);
            white-space: nowrap;
        }

        .markdown-content td {
            border-bottom: 1px solid var(--border-color);
            font-size: 14px;
        }

        .markdown-content tbody tr:hover {
            background-color: rgba(59, 130, 246, 0.05);
            transition: background-color 0.15s ease;
        }

        .markdown-content tbody tr:last-child td {
            border-bottom: none;
        }

        /* Search Results */
        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
            max-height: 400px;
            overflow-y: auto;
            z-index: 1001;
            display: none;
        }

        .search-result-item {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .search-result-item:hover {
            background-color: var(--border-color);
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-title {
            font-weight: 500;
            margin-bottom: 4px;
        }

        .search-result-path {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .search-result-snippet {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .search-highlight {
            background-color: var(--accent-color);
            color: white;
            padding: 1px 2px;
            border-radius: 2px;
        }

        /* Loading and Error States */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            font-size: 16px;
            color: var(--text-secondary);
        }

        .loading::before {
            content: '';
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-color);
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 12px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .theme-toggle:hover {
            background-color: var(--border-color);
            transform: scale(1.05);
        }

        .error {
            padding: 20px;
            text-align: center;
            color: #ef4444;
            background-color: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 8px;
            margin: 20px;
        }

        .error-title {
            font-weight: 600;
            margin-bottom: 8px;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .mobile-menu-button {
                display: block;
            }

            .search-container {
                display: none;
            }

            .sidebar {
                transform: translateX(-100%);
                width: 280px;
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .main-content {
                margin-left: 0;
            }

            .welcome-title {
                font-size: 32px;
            }

            .welcome-stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .quick-access {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .header {
                padding: 0 16px;
            }

            .sidebar-content {
                padding: 16px;
            }

            .content-body {
                padding: 16px;
            }

            .welcome-content {
                padding: 40px 16px;
            }

            .welcome-title {
                font-size: 28px;
            }

            .welcome-stats {
                grid-template-columns: 1fr;
            }

            .pdf-controls {
                flex-direction: column;
                gap: 12px;
            }

            .pdf-controls-left,
            .pdf-controls-right {
                justify-content: center;
            }

            .pdf-canvas-container {
                padding: 10px;
            }

            .content-meta .pdf-button {
                margin-left: 0 !important;
                margin-top: 8px;
                font-size: 11px;
                padding: 5px 8px;
                margin-right: 4px;
            }

            .content-meta {
                gap: 8px;
            }
        }

        /* PDF Viewer Styles */
        .pdf-viewer {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .pdf-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            background-color: var(--surface-color);
            border-bottom: 1px solid var(--border-color);
            gap: 16px;
            flex-wrap: wrap;
        }

        .pdf-controls-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .pdf-controls-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .pdf-button {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s ease;
        }

        .pdf-button:hover {
            background: var(--secondary-color);
        }

        .pdf-button:disabled {
            background: var(--border-color);
            color: var(--text-secondary);
            cursor: not-allowed;
        }

        .pdf-input {
            width: 60px;
            padding: 6px 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--background-color);
            color: var(--text-primary);
            text-align: center;
            font-size: 14px;
        }

        .pdf-info {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .pdf-canvas-container {
            flex: 1;
            overflow: auto;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            background-color: var(--background-color);
        }

        .pdf-canvas {
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-lg);
            max-width: 100%;
            height: auto;
        }

        .pdf-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 400px;
            font-size: 16px;
            color: var(--text-secondary);
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .zoom-level {
            min-width: 60px;
            text-align: center;
            font-size: 14px;
            color: var(--text-secondary);
        }

        /* Utility Classes */
        .hidden {
            display: none !important;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="header-left">
                <button class="mobile-menu-button" onclick="toggleSidebar()">
                    ‚ò∞
                </button>
                <a href="#" class="logo" onclick="showWelcome()">ü§ñ AI Learning Journal</a>
                <div class="search-container">
                    <div class="search-icon">üîç</div>
                    <input type="text" class="search-input" placeholder="Search across all content..." 
                           oninput="handleSearch(this.value)" onblur="hideSearchResults()" onfocus="showSearchResults()">
                    <div class="search-results" id="searchResults"></div>
                </div>
            </div>
            <div class="header-right">
                <button class="theme-toggle" onclick="showTokenStatus()" title="Check GitHub token status and rate limits">
                    <span id="tokenIcon">üìä</span>
                </button>
                <button class="theme-toggle" onclick="updateGitHubToken()" title="Set GitHub Token (optional - increases API rate limit from 60 to 5,000/hour)">
                    <span>üîë</span>
                </button>
                <button class="theme-toggle" onclick="refreshRepository()" title="Refresh repository data">
                    <span id="refreshIcon">üîÑ</span>
                </button>
                <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
                    <span id="themeIcon">üåô</span>
                </button>
            </div>
        </header>

        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-content">
                <div class="sidebar-section">
                    <h3>Categories</h3>
                    <div id="folderList"></div>
                </div>
                
                <div class="sidebar-section">
                    <h3>Recent Files</h3>
                    <div id="recentFiles"></div>
                </div>

                <div class="sidebar-section">
                    <h3>Favorites</h3>
                    <div id="favoriteFiles"></div>
                </div>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content" id="mainContent">
            <div class="content-header" id="contentHeader" style="display: none;">
                <div class="breadcrumb" id="breadcrumb"></div>
                <h1 class="content-title" id="contentTitle"></h1>
                <div class="content-meta" id="contentMeta"></div>
            </div>
            
            <div class="content-body" id="contentBody">
                <div class="welcome-content">
                    <h1 class="welcome-title">AI Learning Journal</h1>
                    <p class="welcome-subtitle">Comprehensive documentation and research notes on artificial intelligence, machine learning, and computer vision</p>
                    
                    <div class="welcome-stats" id="welcomeStats">
                        <div class="stat-card">
                            <div class="stat-value" id="totalFiles">-</div>
                            <div class="stat-label">Total Files</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="totalCategories">-</div>
                            <div class="stat-label">Categories</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="readFiles">0</div>
                            <div class="stat-label">Files Read</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="favoriteCount">0</div>
                            <div class="stat-label">Favorites</div>
                        </div>
                    </div>

                    <div class="recent-updates">
                        <h2 class="section-title">üìù Recent Updates</h2>
                        <div class="recent-files-list" id="recentUpdatesList">
                            <!-- Recent files will be populated here -->
                        </div>
                    </div>

                    <div class="quick-access">
                        <div class="quick-access-item" onclick="expandFolder('3D reconstruction')">
                            <div class="quick-access-icon">üèóÔ∏è</div>
                            <div class="quick-access-title">3D Reconstruction</div>
                            <div class="quick-access-desc">NeRF, Gaussian Splatting, and 3D vision techniques</div>
                        </div>
                        <div class="quick-access-item" onclick="expandFolder('LLM')">
                            <div class="quick-access-icon">üó£Ô∏è</div>
                            <div class="quick-access-title">Large Language Models</div>
                            <div class="quick-access-desc">GPT, LLaMA, and language model research</div>
                        </div>
                        <div class="quick-access-item" onclick="expandFolder('Diffusion_models_GAN')">
                            <div class="quick-access-icon">üé®</div>
                            <div class="quick-access-title">Generative Models</div>
                            <div class="quick-access-desc">Diffusion models, GANs, and image generation</div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // Repository configuration
        const REPO_OWNER = 'linyuanthocr';
        const REPO_NAME = 'AI-Learning-Journal';
        const GITHUB_API_BASE = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}`;
        const GITHUB_RAW_BASE = `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/main`;
        
        // GitHub API Token (optional - increases rate limit from 60 to 5000 requests/hour)
        // To get a token: GitHub Settings > Developer settings > Personal access tokens > Generate new token
        // Only needs 'public_repo' permission for public repositories
        const GITHUB_TOKEN = localStorage.getItem('github-token') || null;
        
        // Helper function to create authenticated GitHub API requests
        function createGitHubRequest(url, options = {}) {
            const headers = {
                'Accept': 'application/vnd.github.v3+json',
                ...options.headers
            };
            
            if (GITHUB_TOKEN) {
                headers['Authorization'] = `token ${GITHUB_TOKEN}`;
                console.log('üîë Using authenticated GitHub API request');
            } else {
                console.log('‚ö†Ô∏è Using unauthenticated GitHub API (limited to 60 requests/hour)');
            }
            
            return fetch(url, {
                ...options,
                headers
            });
        }
        
        // Helper function to try fallback image URLs
        function tryFallbackImage(imgElement, fallbackUrls, altText) {
            if (fallbackUrls.length === 0) {
                // No more fallbacks, show error message
                console.log(`‚ùå All fallback URLs failed for: ${altText}`);
                imgElement.style.display = 'none';
                imgElement.nextElementSibling.style.display = 'block';
                return;
            }
            
            const nextUrl = fallbackUrls.shift();
            console.log(`üîÑ Trying fallback URL for ${altText}:`, nextUrl);
            imgElement.onerror = () => tryFallbackImage(imgElement, fallbackUrls, altText);
            imgElement.src = nextUrl;
        }

        // Application state
        let repositoryData = {};
        let allFiles = [];
        let searchIndex = [];
        let currentFile = null;
        let favorites = JSON.parse(localStorage.getItem('ai-journal-favorites') || '[]');
        let recentFiles = JSON.parse(localStorage.getItem('ai-journal-recent') || '[]');
        let readFiles = JSON.parse(localStorage.getItem('ai-journal-read') || '[]');
        let lastCacheUpdate = localStorage.getItem('ai-journal-cache-timestamp');
        const CACHE_DURATION = 30 * 60 * 1000; // 30 minutes

        // PDF viewer state
        let currentPdf = null;
        let currentPdfPage = 1;
        let pdfScale = 1.0;
        let pdfNumPages = 0;

        // Initialize application
        async function initializeApp() {
            try {
                // Initialize PDF.js worker path early
                if (typeof pdfjsLib !== 'undefined') {
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                    console.log('PDF.js initialized successfully');
                } else {
                    console.warn('PDF.js library not loaded - PDF viewing will not work');
                }
                
                // Load fallback data immediately to show content quickly
                console.log('Loading fallback data immediately for faster startup');
                await loadFallbackStructure();
                console.log('üìÅ Repository data after fallback load:', Object.keys(repositoryData));
                console.log('üìÑ Total files in allFiles:', allFiles.length);
                console.log('üïí Recent files loaded:', recentFiles.length);
                renderSidebar();
                updateStats();
                showWelcome();
                showNotification('‚ú® AI Learning Journal loaded successfully!', 'success');
                
                // Try to load fresh data using improved API methods
                try {
                    console.log('üîÑ Attempting to load repository data from GitHub API...');
                    await loadRepositoryStructure();
                    renderSidebar();
                    updateStats();
                    showNotification('üéâ Repository data loaded from GitHub API!', 'success');
                } catch (bgError) {
                    console.log('‚ö†Ô∏è GitHub API failed, continuing with fallback data:', bgError);
                    showNotification('‚ÑπÔ∏è Using cached data - GitHub API limit reached', 'info');
                }
            } catch (error) {
                console.error('Failed to initialize app:', error);
                
                // If we have fallback data, use it
                if (Object.keys(repositoryData).length > 0) {
                    console.log('Using fallback data');
                    renderSidebar();
                    updateStats();
                    showWelcome();
                    
                    // Show a warning but don't block the app
                    setTimeout(() => {
                        showNotification('‚ö†Ô∏è Using cached data. Some content may not be up to date.', 'warning');
                    }, 1000);
                } else {
                    showError('Failed to load repository data. Please check your internet connection and try again.');
                }
            }
        }

        // Load from cache
        function loadFromCache() {
            const cachedData = localStorage.getItem('ai-journal-cached-data');
            if (cachedData) {
                const parsed = JSON.parse(cachedData);
                repositoryData = parsed.repositoryData || {};
                allFiles = parsed.allFiles || [];
            }
        }

        // Save to cache
        function saveToCache() {
            const cacheData = {
                repositoryData,
                allFiles,
                timestamp: Date.now()
            };
            localStorage.setItem('ai-journal-cached-data', JSON.stringify(cacheData));
            localStorage.setItem('ai-journal-cache-timestamp', Date.now().toString());
        }

        // Refresh repository data
        async function refreshRepository() {
            const refreshIcon = document.getElementById('refreshIcon');
            refreshIcon.style.animation = 'spin 1s linear infinite';
            
            try {
                showLoading('Refreshing repository data...');
                
                // Clear cache
                repositoryData = {};
                allFiles = [];
                
                await loadRepositoryStructure();
                renderSidebar();
                updateStats();
                showWelcome();
                
                showNotification('‚úÖ Repository data refreshed!', 'info');
            } catch (error) {
                console.error('Failed to refresh:', error);
                showNotification('‚ùå Failed to refresh data', 'warning');
            } finally {
                refreshIcon.style.animation = '';
            }
        }

        // Load repository structure from GitHub API using Git Trees API (more efficient)
        async function loadRepositoryStructure() {
            try {
                console.log('üå≥ Loading repository structure using Git Trees API...');
                
                // First, get the main branch commit SHA
                const branchResponse = await createGitHubRequest(`${GITHUB_API_BASE}/branches/main`);
                if (!branchResponse.ok) {
                    throw new Error(`Failed to get branch info: ${branchResponse.status}`);
                }
                const branchData = await branchResponse.json();
                const commitSha = branchData.commit.sha;
                console.log('üìç Main branch commit SHA:', commitSha);
                
                // Get the complete file tree (recursive)
                const treeResponse = await createGitHubRequest(`${GITHUB_API_BASE}/git/trees/${commitSha}?recursive=1`);
                console.log('üå≥ Tree API Response status:', treeResponse.status, treeResponse.statusText);
                
                if (!treeResponse.ok) {
                    console.error('üö® Git Trees API error:', treeResponse.status, treeResponse.statusText);
                    throw new Error(`Git Trees API error: ${treeResponse.status} ${treeResponse.statusText}`);
                }
                
                const treeData = await treeResponse.json();
                console.log('üìÅ Complete file tree loaded:', treeData.tree.length, 'items');
                
                // Process all files from the tree
                const tempRepositoryData = {};
                const tempAllFiles = [];
                
                // Filter for markdown and PDF files, group by directory
                const filesByDirectory = {};
                
                treeData.tree.forEach(item => {
                    if (item.type === 'blob' && (item.path.endsWith('.md') || item.path.endsWith('.pdf'))) {
                        const pathParts = item.path.split('/');
                        if (pathParts.length >= 2) { // At least one directory level
                            const directory = pathParts[0];
                            const filename = pathParts[pathParts.length - 1];
                            
                            if (!filesByDirectory[directory]) {
                                filesByDirectory[directory] = [];
                            }
                            
                            filesByDirectory[directory].push({
                                name: filename,
                                displayName: formatFileDisplayName(filename),
                                path: item.path,
                                downloadUrl: `${GITHUB_RAW_BASE}/${encodeURIComponent(item.path).replace(/%2F/g, '/')}`,
                                size: item.size || 0,
                                type: filename.endsWith('.md') ? 'markdown' : 'pdf',
                                sha: item.sha
                            });
                        }
                    }
                });
                
                console.log('üìÇ Directories found:', Object.keys(filesByDirectory));
                console.log('üìÑ Files per directory:', Object.entries(filesByDirectory).map(([dir, files]) => `${dir}: ${files.length}`));
                
                // Build repository data structure
                Object.entries(filesByDirectory).forEach(([dirName, files]) => {
                    tempRepositoryData[dirName] = {
                        name: dirName,
                        displayName: formatDisplayName(dirName),
                        files: files
                    };
                    
                    // Add to allFiles array
                    files.forEach(file => {
                        tempAllFiles.push({
                            ...file,
                            category: dirName,
                            categoryDisplayName: formatDisplayName(dirName)
                        });
                    });
                });
                
                // Only update global data if we successfully loaded new data
                if (Object.keys(tempRepositoryData).length > 0) {
                    repositoryData = tempRepositoryData;
                    allFiles = tempAllFiles;
                    console.log('üéâ Repository structure loaded successfully using Git Trees API');
                    console.log('üìä Final stats:', {
                        categories: Object.keys(repositoryData).length,
                        totalFiles: allFiles.length,
                        filesByCategory: Object.entries(repositoryData).reduce((acc, [key, data]) => {
                            acc[key] = data.files.length;
                            return acc;
                        }, {})
                    });
                    saveToCache();
                } else {
                    console.warn('‚ö†Ô∏è No new data loaded, keeping existing data');
                }
            } catch (error) {
                console.error('Failed to load repository structure:', error);
                console.log('Keeping existing data due to error');
                throw error; // Re-throw to let caller handle
            }
        }

        // Fallback structure when API fails
        async function loadFallbackStructure() {
            console.log('Using fallback repository structure...');
            
            // Hardcoded structure based on repository analysis
            const fallbackData = {
                '3D reconstruction': {
                    name: '3D reconstruction',
                    displayName: '3D Reconstruction',
                    files: [
                        { name: '3D Gaussian Splatting for Real-Time Radiance Field.md', displayName: '3D Gaussian Splatting for Real-Time Radiance Field', path: '3D reconstruction/3D Gaussian Splatting for Real-Time Radiance Field.md', type: 'markdown' },
                        { name: 'NeRF Representing Scenes as Neural Radiance Fields.md', displayName: 'NeRF Representing Scenes as Neural Radiance Fields', path: '3D reconstruction/NeRF Representing Scenes as Neural Radiance Fields.md', type: 'markdown' },
                        { name: 'DUSt3R Geometric 3D Vision Made Easy.md', displayName: 'DUSt3R Geometric 3D Vision Made Easy', path: '3D reconstruction/DUSt3R Geometric 3D Vision Made Easy.md', type: 'markdown' },
                        { name: 'Instant Neural Graphics Primitives_Instant-NGP.md', displayName: 'Instant Neural Graphics Primitives Instant NGP', path: '3D reconstruction/Instant Neural Graphics Primitives_Instant-NGP.md', type: 'markdown' },
                        { name: 'Segment Anything.md', displayName: 'Segment Anything', path: '3D reconstruction/Segment Anything.md', type: 'markdown' }
                    ]
                },
                'CNN_DL': {
                    name: 'CNN_DL',
                    displayName: 'CNN & Deep Learning',
                    files: [
                        { name: 'Bidirectional LSTM.md', displayName: 'Bidirectional LSTM', path: 'CNN_DL/Bidirectional LSTM.md', type: 'markdown' },
                        { name: 'CLIP variances.md', displayName: 'CLIP Variances', path: 'CNN_DL/CLIP variances.md', type: 'markdown' },
                        { name: 'Contrastive learning.md', displayName: 'Contrastive Learning', path: 'CNN_DL/Contrastive learning.md', type: 'markdown' },
                        { name: 'ResNet.md', displayName: 'ResNet', path: 'CNN_DL/ResNet.md', type: 'markdown' },
                        { name: 'deep learning on mobiles.md', displayName: 'Deep Learning on Mobiles', path: 'CNN_DL/deep learning on mobiles.md', type: 'markdown' },
                        { name: 'LightGlue.md', displayName: 'LightGlue', path: 'CNN_DL/LightGlue.md', type: 'markdown' }
                    ]
                },
                'Diffusion_models_GAN': {
                    name: 'Diffusion_models_GAN',
                    displayName: 'Diffusion Models & GAN',
                    files: [
                        { name: 'Popular Diffusion models.md', displayName: 'Popular Diffusion Models', path: 'Diffusion_models_GAN/Popular Diffusion models.md', type: 'markdown' },
                        { name: 'StableDiffussion.md', displayName: 'Stable Diffusion', path: 'Diffusion_models_GAN/StableDiffussion.md', type: 'markdown' },
                        { name: 'What are Diffusion Models.md', displayName: 'What are Diffusion Models', path: 'Diffusion_models_GAN/What are Diffusion Models.md', type: 'markdown' },
                        { name: 'VQVAE_notes.md', displayName: 'VQ VAE Notes', path: 'Diffusion_models_GAN/VQVAE_notes.md', type: 'markdown' }
                    ]
                },
                'Generative AI': {
                    name: 'Generative AI',
                    displayName: 'Generative AI',
                    files: [
                        { name: 'Generative AI for Beginners.md', displayName: 'Generative AI for Beginners', path: 'Generative AI/Generative AI for Beginners.md', type: 'markdown' },
                        { name: 'Lora training.md', displayName: 'LoRA Training', path: 'Generative AI/Lora training.md', type: 'markdown' },
                        { name: 'Training lora.md', displayName: 'Training LoRA', path: 'Generative AI/Training lora.md', type: 'markdown' }
                    ]
                },
                'LLM': {
                    name: 'LLM',
                    displayName: 'Large Language Models',
                    files: [
                        { name: 'Generalized Language Models.md', displayName: 'Generalized Language Models', path: 'LLM/Generalized Language Models.md', type: 'markdown' },
                        { name: 'Instruct GPT.md', displayName: 'Instruct GPT', path: 'LLM/Instruct GPT.md', type: 'markdown' },
                        { name: 'LORA.md', displayName: 'LoRA', path: 'LLM/LORA.md', type: 'markdown' },
                        { name: 'PALM.md', displayName: 'PaLM', path: 'LLM/PALM.md', type: 'markdown' },
                        { name: 'RAG survey.md', displayName: 'RAG Survey', path: 'LLM/RAG survey.md', type: 'markdown' },
                        { name: 'Self_instruct.md', displayName: 'Self Instruct', path: 'LLM/Self_instruct.md', type: 'markdown' }
                    ]
                },
                'Transformers&beyond': {
                    name: 'Transformers&beyond',
                    displayName: 'Transformers & Beyond',
                    files: [
                        { name: 'Distillation.md', displayName: 'Distillation', path: 'Transformers&beyond/Distillation.md', type: 'markdown' },
                        { name: 'Flash Attention.md', displayName: 'Flash Attention', path: 'Transformers&beyond/Flash Attention.md', type: 'markdown' },
                        { name: 'IMAGEBIND.md', displayName: 'ImageBind', path: 'Transformers&beyond/IMAGEBIND.md', type: 'markdown' },
                        { name: 'Knowledge_Dis.md', displayName: 'Knowledge Distillation', path: 'Transformers&beyond/Knowledge_Dis.md', type: 'markdown' },
                        { name: 'LoFTRÔºöDetector-Free Local Feature Matching.md', displayName: 'LoFTR: Detector-Free Local Feature Matching', path: 'Transformers&beyond/LoFTRÔºöDetector-Free Local Feature Matching.md', type: 'markdown' },
                        { name: 'MOCO_ Momentum Contrast for Unsupervised Visual Re.md', displayName: 'MOCO: Momentum Contrast for Unsupervised Visual Representation Learning', path: 'Transformers&beyond/MOCO_ Momentum Contrast for Unsupervised Visual Re.md', type: 'markdown' },
                        { name: 'Mamba.md', displayName: 'Mamba', path: 'Transformers&beyond/Mamba.md', type: 'markdown' },
                        { name: 'Multimodal Foundation Models.md', displayName: 'Multimodal Foundation Models', path: 'Transformers&beyond/Multimodal Foundation Models.md', type: 'markdown' },
                        { name: 'S4 model Long Sequences with Structured State Spac.md', displayName: 'S4 Model: Long Sequences with Structured State Spaces', path: 'Transformers&beyond/S4 model Long Sequences with Structured State Spac.md', type: 'markdown' },
                        { name: 'Transformer Family 2 0.md', displayName: 'Transformer Family 2.0', path: 'Transformers&beyond/Transformer Family 2 0.md', type: 'markdown' },
                        { name: 'ViT.md', displayName: 'Vision Transformer', path: 'Transformers&beyond/ViT.md', type: 'markdown' }
                    ]
                },
                'MDE': {
                    name: 'MDE',
                    displayName: 'Monocular Depth Estimation',
                    files: [
                        { name: 'MDE_basics.md', displayName: 'Monocular Depth Estimation Basics', path: 'MDE/MDE_basics.md', type: 'markdown' }
                    ]
                },
                'Matching&tracking': {
                    name: 'Matching&tracking',
                    displayName: 'Matching & Tracking',
                    files: [
                        { name: 'tracking_basics.md', displayName: 'Tracking Basics', path: 'Matching&tracking/tracking_basics.md', type: 'markdown' }
                    ]
                },
                'Tools_Usage': {
                    name: 'Tools_Usage',
                    displayName: 'Tools & Usage',
                    files: [
                        { name: 'git_usage.md', displayName: 'Git Usage', path: 'Tools_Usage/git_usage.md', type: 'markdown' }
                    ]
                },
                'VO_VIO_VSLAM': {
                    name: 'VO_VIO_VSLAM',
                    displayName: 'Visual Odometry & SLAM',
                    files: [
                        { name: 'SLAM_basics.md', displayName: 'SLAM Basics', path: 'VO_VIO_VSLAM/SLAM_basics.md', type: 'markdown' }
                    ]
                }
            };
            
            // Populate repository data with fallback
            console.log('Processing fallback data with', Object.keys(fallbackData).length, 'categories');
            Object.entries(fallbackData).forEach(([key, data]) => {
                console.log(`Processing category: ${key} with ${data.files.length} files`);
                
                // Add downloadUrl to each file in the data
                const filesWithDownloadUrl = data.files.map(file => ({
                    ...file,
                    downloadUrl: `${GITHUB_RAW_BASE}/${encodeURIComponent(file.path).replace(/%2F/g, '/')}`
                }));
                
                // Store the updated data
                repositoryData[key] = {
                    ...data,
                    files: filesWithDownloadUrl
                };
                
                // Add files to search index
                filesWithDownloadUrl.forEach(file => {
                    if (file && file.path) {
                        allFiles.push({
                            ...file,
                            category: key,
                            categoryDisplayName: data.displayName
                        });
                    } else {
                        console.warn('Invalid file object in fallback data:', file);
                    }
                });
            });
            
            console.log('Fallback data loaded - repositoryData:', Object.keys(repositoryData));
            console.log('Total files in allFiles:', allFiles.length);
            
            // Add some default recent files for immediate display using actual existing files
            if (recentFiles.length === 0) {
                recentFiles = [
                    {
                        name: 'DUSt3R Geometric 3D Vision Made Easy.md',
                        path: '3D reconstruction/DUSt3R Geometric 3D Vision Made Easy.md',
                        displayName: 'DUSt3R: Geometric 3D Vision Made Easy',
                        summary: 'Revolutionary 3D reconstruction approach using neural radiance fields',
                        category: '3D reconstruction',
                        categoryDisplayName: '3D Reconstruction',
                        type: 'markdown',
                        downloadUrl: `${GITHUB_RAW_BASE}/3D reconstruction/DUSt3R Geometric 3D Vision Made Easy.md`,
                        timestamp: Date.now() - 86400000 // 1 day ago
                    },
                    {
                        name: 'Flash Attention.md',
                        path: 'Transformers&beyond/Flash Attention.md',
                        displayName: 'Flash Attention: Memory-Efficient Attention',
                        summary: 'Optimized attention mechanism for faster transformer training',
                        category: 'Transformers&beyond',
                        categoryDisplayName: 'Transformers & Beyond',
                        type: 'markdown',
                        downloadUrl: `${GITHUB_RAW_BASE}/${encodeURIComponent('Transformers&beyond/Flash Attention.md').replace(/%2F/g, '/')}`,
                        timestamp: Date.now() - 172800000 // 2 days ago
                    },
                    {
                        name: 'Mamba.md',
                        path: 'Transformers&beyond/Mamba.md',
                        displayName: 'Mamba: Linear-Time Sequence Modeling',
                        summary: 'State-space models for efficient long sequence processing',
                        category: 'Transformers&beyond',
                        categoryDisplayName: 'Transformers & Beyond',
                        type: 'markdown',
                        downloadUrl: `${GITHUB_RAW_BASE}/${encodeURIComponent('Transformers&beyond/Mamba.md').replace(/%2F/g, '/')}`,
                        timestamp: Date.now() - 259200000 // 3 days ago
                    }
                ];
                localStorage.setItem('ai-journal-recent', JSON.stringify(recentFiles));
            }
        }

        // Load contents of a specific directory
        async function loadDirectoryContents(dirName, targetRepositoryData = repositoryData, targetAllFiles = allFiles) {
            try {
                const url = `${GITHUB_API_BASE}/contents/${encodeURIComponent(dirName)}`;
                console.log(`Loading directory contents for: ${dirName}`);
                console.log(`Directory API URL: ${url}`);
                
                const response = await fetch(url);
                console.log(`Directory ${dirName} response:`, response.status, response.statusText);
                
                if (!response.ok) {
                    console.error(`Failed to load directory ${dirName}:`, response.status, response.statusText);
                    return;
                }
                
                const contents = await response.json();
                console.log(`Raw contents in ${dirName}:`, contents.length, 'items');
                const files = contents.filter(item => 
                    item.type === 'file' && 
                    (item.name.endsWith('.md') || item.name.endsWith('.pdf')) &&
                    !item.name.startsWith('.')
                );
                console.log(`Filtered files in ${dirName}:`, files.length, 'items');
                console.log(`File names:`, files.map(f => f.name));
                // Debug: Log what fields are available
                if (files.length > 0) {
                    console.log('Sample file object keys:', Object.keys(files[0]));
                    console.log('Sample file data:', files[0]);
                }
                
                // Process files and handle duplicate display names
                const processedFiles = [];
                const displayNameCounts = {};
                
                files.forEach(file => {
                    let displayName = formatFileDisplayName(file.name);
                    
                    // Handle duplicates by adding numbers
                    if (displayNameCounts[displayName]) {
                        displayNameCounts[displayName]++;
                        displayName = `${displayName} (${displayNameCounts[displayName]})`;
                    } else {
                        displayNameCounts[displayName] = 1;
                    }
                    
                    processedFiles.push({
                        name: file.name,
                        displayName: displayName,
                        path: file.path,
                        downloadUrl: file.download_url,
                        size: file.size,
                        type: file.name.endsWith('.md') ? 'markdown' : 'pdf',
                        lastModified: file.updated_at || file.last_modified || new Date().toISOString()
                    });
                });
                
                targetRepositoryData[dirName] = {
                    name: dirName,
                    displayName: formatDisplayName(dirName),
                    files: processedFiles
                };
                
                // Add files to search index
                processedFiles.forEach(file => {
                    targetAllFiles.push({
                        name: file.name,
                        displayName: file.displayName,
                        path: file.path,
                        category: dirName,
                        categoryDisplayName: formatDisplayName(dirName),
                        downloadUrl: file.downloadUrl,
                        size: file.size,
                        type: file.type,
                        lastModified: file.lastModified
                    });
                });
            } catch (error) {
                console.error(`Failed to load directory ${dirName}:`, error);
            }
        }

        // Format display names
        function formatDisplayName(name) {
            if (!name || typeof name !== 'string') {
                console.warn('formatDisplayName called with invalid name:', name);
                return '';
            }
            return name
                .replace(/[_&]/g, ' ')
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        function formatFileDisplayName(filename) {
            if (!filename || typeof filename !== 'string') {
                console.warn('formatFileDisplayName called with invalid filename:', filename);
                return '';
            }
            let nameWithoutExt = filename.replace(/\.(md|pdf)$/, '');
            
            // Only remove hash at the very end - be more specific
            nameWithoutExt = nameWithoutExt
                // Remove space + hash at end (like " 4a81adda3eb6405cbe8db8685390307b")
                .replace(/\s+[a-f0-9]{32}$/i, '')
                .replace(/\s+[a-f0-9]{20,}$/i, '');
            
            // Remove dates only at beginning or end
            nameWithoutExt = nameWithoutExt
                .replace(/^\d{4}\.\d{2}\.\d{2}\s+/g, '') // Remove dates like "2019.07.14 " at start
                .replace(/^\d{4}-\d{2}-\d{2}\s+/g, '') // Remove dates like "2019-07-14 " at start
                .replace(/\s+\d{4}\.\d{2}\.\d{2}$/g, '') // Remove dates at end
                .replace(/\s+\d{4}-\d{2}-\d{2}$/g, ''); // Remove dates at end
            
            // Clean up the name
            return nameWithoutExt
                .replace(/[_-]/g, ' ')
                .replace(/([a-z])([A-Z])/g, '$1 $2')
                .replace(/\s+/g, ' ') // Replace multiple spaces with single space
                .trim()
                .split(' ')
                .filter(word => word.length > 0) // Remove empty words
                .map(word => {
                    // Keep common abbreviations uppercase
                    if (['AI', 'ML', 'DL', 'CNN', 'RNN', 'LSTM', 'GAN', 'VAE', 'API', 'GPU', 'CPU', 'LLM', 'GPT', 'GPT2', 'GPT3', 'GPT4', 'BERT', 'ViT', 'CLIP', 'SLAM', 'NeRF', '3D', '2D', 'VINS', 'MAE', 'DDPM', 'VQVAE', 'PIX2PIX'].includes(word.toUpperCase())) {
                        return word.toUpperCase();
                    }
                    // Capitalize first letter of other words
                    return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
                })
                .join(' ')
                .substring(0, 60) // Limit to 60 characters
                .trim();
        }

        // Render sidebar
        function renderSidebar() {
            console.log('üé® renderSidebar called');
            console.log('üìÅ repositoryData keys:', Object.keys(repositoryData));
            console.log('üìä repositoryData structure:', repositoryData);
            
            const folderList = document.getElementById('folderList');
            if (!folderList) {
                console.error('‚ùå folderList element not found!');
                return;
            }
            
            console.log('‚úÖ folderList element found, clearing content');
            folderList.innerHTML = '';
            
            if (Object.keys(repositoryData).length === 0) {
                console.warn('‚ö†Ô∏è No repository data to render');
                folderList.innerHTML = '<p style="color: var(--text-secondary); padding: 16px;">No categories found. Please refresh to reload data.</p>';
                return;
            }
            
            console.log(`üóÇÔ∏è Processing ${Object.keys(repositoryData).length} categories`);
            Object.entries(repositoryData).sort().forEach(([folderName, folderData]) => {
                console.log(`üìÇ Rendering folder: ${folderName} with ${folderData.files ? folderData.files.length : 0} files`);
                if (!folderData.files || folderData.files.length === 0) {
                    console.warn(`‚ö†Ô∏è Folder ${folderName} has no files:`, folderData);
                }
                const folderElement = createFolderElement(folderData);
                folderList.appendChild(folderElement);
            });
            
            console.log('üïí Rendering recent files...');
            renderRecentFiles();
            console.log('‚≠ê Rendering favorite files...');
            renderFavoriteFiles();
            console.log('‚úÖ Sidebar rendering complete');
        }

        // Create folder element
        function createFolderElement(folderData) {
            const folderDiv = document.createElement('div');
            folderDiv.className = 'folder-item';
            
            const headerDiv = document.createElement('div');
            headerDiv.className = 'folder-header';
            headerDiv.onclick = () => toggleFolder(folderData.name);
            
            headerDiv.innerHTML = `
                <span class="folder-icon">‚ñ∂</span>
                <span class="folder-name">${folderData.displayName}</span>
                <span class="file-count">${folderData.files.length}</span>
            `;
            
            const fileList = document.createElement('div');
            fileList.className = 'file-list';
            fileList.id = `files-${folderData.name}`;
            
            folderData.files.forEach(file => {
                const fileElement = createFileElement(file, folderData.name);
                fileList.appendChild(fileElement);
            });
            
            folderDiv.appendChild(headerDiv);
            folderDiv.appendChild(fileList);
            
            return folderDiv;
        }

        // Create file element
        function createFileElement(file, categoryName) {
            const fileDiv = document.createElement('div');
            fileDiv.className = 'file-item';
            fileDiv.onclick = () => loadFile(file, categoryName);
            
            const icon = file.type === 'markdown' ? 'üìÑ' : 'üìã';
            const isFavorite = favorites.includes(file.path);
            
            fileDiv.innerHTML = `
                <span class="file-icon">${icon}</span>
                <span class="file-name">${file.displayName}</span>
                <span class="favorite-icon ${isFavorite ? 'active' : ''}" 
                      onclick="event.stopPropagation(); toggleFavorite('${file.path}')">
                    ‚≠ê
                </span>
            `;
            
            return fileDiv;
        }

        // Toggle folder expansion
        function toggleFolder(folderName) {
            const header = document.querySelector(`[onclick*="${folderName}"]`);
            const fileList = document.getElementById(`files-${folderName}`);
            
            header.classList.toggle('expanded');
            fileList.classList.toggle('expanded');
        }

        // Expand folder (for quick access)
        function expandFolder(folderName) {
            const header = document.querySelector(`[onclick*="${folderName}"]`);
            const fileList = document.getElementById(`files-${folderName}`);
            
            if (header && fileList) {
                header.classList.add('expanded');
                fileList.classList.add('expanded');
                
                // Scroll to folder
                header.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // Sanitize strings for safe DOM usage
        function sanitizeForDOM(str) {
            if (!str) return '';
            return str
                .replace(/Ôºö([^\s])/g, 'Ôºö $1')  // Add space after Chinese colons if missing
                .replace(/:([^\s])/g, ': $1')   // Add space after regular colons if missing
                .replace(/'/g, '&#39;')         // Single quotes to HTML entity
                .replace(/"/g, '&quot;')        // Double quotes to HTML entity
                .replace(/</g, '&lt;')      // Less than to HTML entity
                .replace(/>/g, '&gt;')      // Greater than to HTML entity
                .replace(/&/g, '&amp;')     // Ampersand to HTML entity (do this last)
                .trim();
        }

        // Sanitize strings for safe JavaScript usage
        function sanitizeForJS(str) {
            if (!str) return '';
            return str
                .replace(/Ôºö([^\s])/g, 'Ôºö $1')  // Add space after Chinese colons if missing
                .replace(/:([^\s])/g, ': $1')   // Add space after regular colons if missing
                .replace(/'/g, "\\'")           // Escape single quotes for JS
                .replace(/"/g, '\\"')           // Escape double quotes for JS
                .replace(/\\/g, '\\\\')     // Escape backslashes
                .trim();
        }

        // Ensure DOM elements are ready
        function ensureContentElementsReady() {
            const elements = ['contentHeader', 'breadcrumb', 'contentTitle', 'contentMeta', 'contentBody'];
            const missing = elements.filter(id => !document.getElementById(id));
            
            if (missing.length > 0) {
                console.warn('‚ö†Ô∏è Content elements not ready:', missing);
                return false;
            }
            return true;
        }

        // Load and display file
        async function loadFile(file, categoryName) {
            try {
                console.log('üöÄ loadFile called with:', { file, categoryName });
                
                // Special debug for FLAME files
                if (file && file.name && file.name.toLowerCase().includes('flame')) {
                    console.log('üî• FLAME file loading details:', {
                        name: file.name,
                        path: file.path,
                        downloadUrl: file.downloadUrl,
                        displayName: file.displayName
                    });
                }
                
                // Ensure DOM is ready
                if (!ensureContentElementsReady()) {
                    console.log('‚è≥ Waiting for DOM elements to be ready...');
                    // Wait a brief moment for DOM to be ready, then try again
                    await new Promise(resolve => setTimeout(resolve, 100));
                    if (!ensureContentElementsReady()) {
                        throw new Error('Content elements not available after waiting');
                    }
                }
                
                // Validate file object
                if (!file) {
                    throw new Error('File object is null or undefined');
                }
                
                console.log('üîç File object details:', {
                    hasPath: !!file.path,
                    hasDownloadUrl: !!file.downloadUrl,
                    hasName: !!file.name,
                    hasDisplayName: !!file.displayName,
                    path: file.path,
                    downloadUrl: file.downloadUrl,
                    name: file.name,
                    displayName: file.displayName,
                    type: file.type,
                    allKeys: Object.keys(file)
                });
                
                if (!file.path) {
                    console.error('‚ùå File object missing path property:', file);
                    throw new Error('File object is missing required path property');
                }
                
                if (!file.downloadUrl) {
                    console.warn('‚ö†Ô∏è File missing downloadUrl, will construct from path');
                    file.downloadUrl = `${GITHUB_RAW_BASE}/${encodeURIComponent(file.path).replace(/%2F/g, '/')}`;
                    console.log('‚úÖ Constructed downloadUrl:', file.downloadUrl);
                }
                
                showLoading('Loading file...');
                console.log('üìÑ Loading file:', file.path, 'URL:', file.downloadUrl);
                
                // Update UI first
                setActiveFile(file.path);
                
                if (file.type === 'pdf') {
                    // Load PDF inline
                    await showPdfContent(file, categoryName);
                } else {
                    // Construct GitHub raw URL if downloadUrl is not available
                    let fileUrl = file.downloadUrl;
                    if (!fileUrl) {
                        fileUrl = `${GITHUB_RAW_BASE}/${file.path}`;
                        console.log('Using constructed URL:', fileUrl);
                    }
                    
                    // Load markdown file
                    console.log('Fetching from URL:', fileUrl);
                    const response = await fetch(fileUrl, {
                        method: 'GET',
                        headers: {
                            'Accept': 'text/plain, text/markdown, */*',
                            'Content-Type': 'text/plain'
                        },
                        mode: 'cors'
                    });
                    
                    console.log('Response status:', response.status, response.statusText);
                    
                    if (!response.ok) {
                        console.error('‚ùå Failed to fetch file:', {
                            url: fileUrl,
                            status: response.status,
                            statusText: response.statusText,
                            file: file
                        });
                        
                        // Try alternative URL construction
                        if (fileUrl.includes('%20')) {
                            const altUrl = fileUrl.replace(/%20/g, ' ');
                            console.log('üîÑ Trying alternative URL without encoding:', altUrl);
                            const altResponse = await fetch(altUrl, {
                                method: 'GET',
                                headers: {
                                    'Accept': 'text/plain, text/markdown, */*',
                                    'Content-Type': 'text/plain'
                                },
                                mode: 'cors'
                            });
                            if (altResponse.ok) {
                                console.log('‚úÖ Alternative URL worked!');
                                const content = await altResponse.text();
                                showFileContent(file, categoryName, content);
                                return;
                            } else {
                                console.error('‚ùå Alternative URL also failed:', altResponse.status, altResponse.statusText);
                            }
                        }
                        
                        // Try with different encoding
                        const encodedUrl = `${GITHUB_RAW_BASE}/${encodeURIComponent(file.path)}`;
                        console.log('üîÑ Trying fully encoded URL:', encodedUrl);
                        try {
                            const encodedResponse = await fetch(encodedUrl);
                            if (encodedResponse.ok) {
                                console.log('‚úÖ Fully encoded URL worked!');
                                const content = await encodedResponse.text();
                                showFileContent(file, categoryName, content);
                                return;
                            }
                        } catch (e) {
                            console.error('‚ùå Encoded URL failed:', e);
                        }
                        
                        throw new Error(`HTTP ${response.status}: ${response.statusText}. File: ${file.path}`);
                    }
                    
                    const content = await response.text();
                    console.log('File loaded successfully, content length:', content.length);
                    
                    showFileContent(file, categoryName, content);
                }
                
                // Update recent files and read tracking
                addToRecentFiles(file, categoryName);
                markAsRead(file.path);
                
                // Update URL hash for direct linking
                console.log('üìç Updating URL hash with file.path:', JSON.stringify(file.path));
                updateUrlHash(file.path);
                
            } catch (error) {
                console.error('Failed to load file:', error);
                console.error('File object:', file);
                showError(`Failed to load file: ${error.message}. Please check the browser console for more details.`);
            }
        }

        // Show file content
        function showFileContent(file, categoryName, content) {
            console.log('üé® showFileContent called for:', file.displayName);
            
            // Get content elements with null checking
            const contentHeader = document.getElementById('contentHeader');
            const breadcrumb = document.getElementById('breadcrumb');
            const contentTitle = document.getElementById('contentTitle');
            const contentMeta = document.getElementById('contentMeta');
            const contentBody = document.getElementById('contentBody');
            
            // Verify all required elements exist
            const requiredElements = {
                contentHeader,
                breadcrumb, 
                contentTitle,
                contentMeta,
                contentBody
            };
            
            const missingElements = Object.entries(requiredElements)
                .filter(([name, element]) => !element)
                .map(([name]) => name);
                
            if (missingElements.length > 0) {
                console.error('‚ùå Missing required DOM elements:', missingElements);
                showError(`UI Error: Missing elements - ${missingElements.join(', ')}. Please refresh the page.`);
                return;
            }
            
            console.log('‚úÖ All content elements found, proceeding with file display');
            
            // CRITICAL: Make content header visible FIRST, then access child elements
            contentHeader.style.display = 'block';
            hideLoading(); // Make sure any loading states are cleared
            
            // Update breadcrumb with safe character escaping using sanitization functions
            breadcrumb.innerHTML = `
                <span onclick="showWelcome()" style="cursor: pointer; color: var(--primary-color);">Home</span>
                <span class="breadcrumb-separator">‚Ä∫</span>
                <span onclick="expandFolder('${sanitizeForJS(categoryName)}'); event.stopPropagation();" style="cursor: pointer; color: var(--primary-color);">${sanitizeForDOM(formatDisplayName(categoryName))}</span>
                <span class="breadcrumb-separator">‚Ä∫</span>
                <span>${sanitizeForDOM(file.displayName)}</span>
            `;
            
            // Update title and meta with safety check using verified elements
            console.log('üìù Setting content title:', { element: contentTitle, text: file.displayName });
            if (contentTitle) {
                contentTitle.textContent = file.displayName;
            } else {
                console.error('‚ùå contentTitle is null when trying to set textContent');
                throw new Error('contentTitle element is null');
            }
            contentMeta.innerHTML = `
                <span>üìÅ ${formatDisplayName(categoryName)}</span>
                <span>üìÑ ${file.type === 'markdown' ? 'Markdown' : 'PDF'}</span>
                <span>üìä ${formatFileSize(file.size || 0)}</span>
                <button class="pdf-button" onclick="downloadFile('${sanitizeForJS(file.downloadUrl || '')}', '${sanitizeForJS(file.name || file.displayName || '')}'); event.stopPropagation();" style="margin-left: 16px;">
                    üíæ Download
                </button>
                <button class="pdf-button" onclick="viewInGitHub('${sanitizeForJS(file.path || '')}'); event.stopPropagation();" style="margin-left: 8px;">
                    üìã View in GitHub
                </button>
                <button class="pdf-button" onclick="copyFileLink('${sanitizeForJS(file.path || '')}'); event.stopPropagation();" style="margin-left: 8px;">
                    üîó Copy Link
                </button>
            `;
            
            // Show header and render content
            contentHeader.style.display = 'block';
            contentBody.classList.remove('loading');
            contentBody.innerHTML = `<div class="markdown-content">${renderMarkdown(content, file.path)}</div>`;
            
            // Apply syntax highlighting
            if (window.Prism) {
                Prism.highlightAllUnder(contentBody);
            }
            
            // Re-render MathJax equations
            if (window.MathJax) {
                MathJax.typesetPromise([contentBody]).catch(function (err) {
                    console.log('MathJax typeset failed: ' + err.message);
                });
            }
            
            currentFile = { ...file, categoryName };
        }

        // Show PDF content
        async function showPdfContent(file, categoryName) {
            const contentHeader = document.getElementById('contentHeader');
            const breadcrumb = document.getElementById('breadcrumb');
            const contentTitle = document.getElementById('contentTitle');
            const contentMeta = document.getElementById('contentMeta');
            const contentBody = document.getElementById('contentBody');
            
            // Update breadcrumb with safe character escaping using sanitization functions
            breadcrumb.innerHTML = `
                <span onclick="showWelcome()" style="cursor: pointer; color: var(--primary-color);">Home</span>
                <span class="breadcrumb-separator">‚Ä∫</span>
                <span onclick="expandFolder('${sanitizeForJS(categoryName)}'); event.stopPropagation();" style="cursor: pointer; color: var(--primary-color);">${sanitizeForDOM(formatDisplayName(categoryName))}</span>
                <span class="breadcrumb-separator">‚Ä∫</span>
                <span>${sanitizeForDOM(file.displayName)}</span>
            `;
            
            // Update title and meta with safety check (PDF version)
            console.log('üìù Setting PDF content title:', { element: contentTitle, text: file.displayName });
            if (contentTitle) {
                contentTitle.textContent = file.displayName;
            } else {
                console.error('‚ùå PDF contentTitle is null when trying to set textContent');
                throw new Error('PDF contentTitle element is null');
            }
            contentMeta.innerHTML = `
                <span>üìÅ ${formatDisplayName(categoryName)}</span>
                <span>üìã PDF Document</span>
                <span>üìä ${formatFileSize(file.size || 0)}</span>
            `;
            
            // Show header
            contentHeader.style.display = 'block';
            
            // Create PDF viewer HTML
            contentBody.innerHTML = `
                <div class="pdf-viewer">
                    <div class="pdf-controls">
                        <div class="pdf-controls-left">
                            <button class="pdf-button" onclick="previousPage()" id="prevPageBtn">
                                ‚óÄ Previous
                            </button>
                            <input type="number" class="pdf-input" id="pageInput" value="1" min="1" onchange="goToPage(this.value)">
                            <span class="pdf-info">of <span id="totalPages">-</span></span>
                            <button class="pdf-button" onclick="nextPage()" id="nextPageBtn">
                                Next ‚ñ∂
                            </button>
                        </div>
                        <div class="pdf-controls-right">
                            <div class="zoom-controls">
                                <button class="pdf-button" onclick="zoomOut()">üîç-</button>
                                <span class="zoom-level" id="zoomLevel">100%</span>
                                <button class="pdf-button" onclick="zoomIn()">üîç+</button>
                            </div>
                            <button class="pdf-button" onclick="downloadPdf()">
                                üíæ Download
                            </button>
                            <button class="pdf-button" onclick="viewInGitHub('${sanitizeForJS(file.path || '')}')">
                                üìã View in GitHub
                            </button>
                        </div>
                    </div>
                    <div class="pdf-canvas-container">
                        <div class="pdf-loading" id="pdfLoading">Loading PDF...</div>
                        <canvas id="pdfCanvas" class="pdf-canvas" style="display: none;"></canvas>
                    </div>
                </div>
            `;
            
            // Load the PDF with a small delay to ensure DOM is ready
            setTimeout(async () => {
                await loadPdf(file.downloadUrl);
            }, 100);
            
            currentFile = { ...file, categoryName };
        }

        // Load PDF using PDF.js
        async function loadPdf(url) {
            const loadingElement = document.getElementById('pdfLoading');
            
            try {
                console.log('Loading PDF from:', url);
                
                // Check if PDF.js is available
                if (typeof pdfjsLib === 'undefined') {
                    throw new Error('PDF.js library not loaded');
                }
                
                const loadingTask = pdfjsLib.getDocument(url);
                currentPdf = await loadingTask.promise;
                pdfNumPages = currentPdf.numPages;
                currentPdfPage = 1;
                
                console.log(`PDF loaded successfully: ${pdfNumPages} pages`);
                
                // Update UI with null checks
                const totalPagesElement = document.getElementById('totalPages');
                const pageInputElement = document.getElementById('pageInput');
                const pdfLoadingElement = document.getElementById('pdfLoading');
                const pdfCanvasElement = document.getElementById('pdfCanvas');
                
                if (totalPagesElement) {
                    totalPagesElement.textContent = pdfNumPages;
                }
                if (pageInputElement) {
                    pageInputElement.max = pdfNumPages;
                    pageInputElement.value = 1;
                }
                
                // Render first page
                await renderPdfPage(1);
                
                // Hide loading, show canvas
                if (pdfLoadingElement) {
                    pdfLoadingElement.style.display = 'none';
                }
                if (pdfCanvasElement) {
                    pdfCanvasElement.style.display = 'block';
                }
                
                updatePdfControls();
                updateZoomLevel();
                
            } catch (error) {
                console.error('Failed to load PDF:', error);
                if (loadingElement) {
                    loadingElement.innerHTML = `
                        <div style="text-align: center;">
                            <div style="color: #ef4444; margin-bottom: 12px;">‚ùå Failed to load PDF</div>
                            <div style="color: var(--text-secondary); margin-bottom: 16px;">${error.message}</div>
                            <button class="pdf-button" onclick="window.open('${url}', '_blank')">
                                Open in New Tab
                            </button>
                        </div>
                    `;
                }
            }
        }

        // Render a specific PDF page
        async function renderPdfPage(pageNum) {
            if (!currentPdf) return;
            
            try {
                const page = await currentPdf.getPage(pageNum);
                const canvas = document.getElementById('pdfCanvas');
                
                if (!canvas) {
                    console.error('PDF canvas element not found');
                    return;
                }
                
                const context = canvas.getContext('2d');
                
                // Calculate scale to fit container
                const containerWidth = canvas.parentElement.clientWidth - 40; // Account for padding
                const viewport = page.getViewport({ scale: 1.0 });
                const scale = Math.min(pdfScale, containerWidth / viewport.width);
                
                const scaledViewport = page.getViewport({ scale });
                
                // Set canvas dimensions
                canvas.height = scaledViewport.height;
                canvas.width = scaledViewport.width;
                
                // Render page
                const renderContext = {
                    canvasContext: context,
                    viewport: scaledViewport
                };
                
                await page.render(renderContext).promise;
                
                currentPdfPage = pageNum;
                
                // Update page input with null check
                const pageInputElement = document.getElementById('pageInput');
                if (pageInputElement) {
                    pageInputElement.value = pageNum;
                }
                
            } catch (error) {
                console.error('Failed to render PDF page:', error);
            }
        }

        // PDF navigation functions
        async function nextPage() {
            if (currentPdfPage < pdfNumPages) {
                await renderPdfPage(currentPdfPage + 1);
                updatePdfControls();
            }
        }

        async function previousPage() {
            if (currentPdfPage > 1) {
                await renderPdfPage(currentPdfPage - 1);
                updatePdfControls();
            }
        }

        async function goToPage(pageNum) {
            const page = parseInt(pageNum);
            if (page >= 1 && page <= pdfNumPages) {
                await renderPdfPage(page);
                updatePdfControls();
            }
        }

        // PDF zoom functions
        async function zoomIn() {
            pdfScale = Math.min(pdfScale * 1.2, 3.0);
            await renderPdfPage(currentPdfPage);
            updateZoomLevel();
        }

        async function zoomOut() {
            pdfScale = Math.max(pdfScale / 1.2, 0.5);
            await renderPdfPage(currentPdfPage);
            updateZoomLevel();
        }

        function updateZoomLevel() {
            const zoomElement = document.getElementById('zoomLevel');
            if (zoomElement) {
                zoomElement.textContent = Math.round(pdfScale * 100) + '%';
            }
        }

        function updatePdfControls() {
            const prevBtn = document.getElementById('prevPageBtn');
            const nextBtn = document.getElementById('nextPageBtn');
            
            if (prevBtn) {
                prevBtn.disabled = currentPdfPage <= 1;
            }
            if (nextBtn) {
                nextBtn.disabled = currentPdfPage >= pdfNumPages;
            }
        }

        function downloadPdf() {
            if (currentFile && currentFile.downloadUrl) {
                downloadFile(currentFile.downloadUrl, currentFile.name);
            }
        }

        // Generic download function
        function downloadFile(url, filename) {
            try {
                // Create a temporary link element
                const link = document.createElement('a');
                link.href = url;
                link.download = filename || 'download';
                link.target = '_blank';
                
                // Append to body, click, and remove
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showNotification(`üì• Downloading ${filename}`, 'info');
            } catch (error) {
                console.error('Download failed:', error);
                // Fallback to opening in new tab
                window.open(url, '_blank');
            }
        }

        // Copy direct link to file
        async function copyFileLink(filePath) {
            try {
                const url = `${window.location.origin}${window.location.pathname}#file:${encodeURIComponent(filePath)}`;
                await navigator.clipboard.writeText(url);
                showNotification('üîó Link copied to clipboard!', 'info');
            } catch (error) {
                console.error('Failed to copy link:', error);
                // Fallback for browsers that don't support clipboard API
                const url = `${window.location.origin}${window.location.pathname}#file:${encodeURIComponent(filePath)}`;
                prompt('Copy this link:', url);
            }
        }

        // View file in GitHub
        function viewInGitHub(filePath) {
            try {
                // Construct GitHub URL for the file
                const githubUrl = `https://github.com/${REPO_OWNER}/${REPO_NAME}/blob/main/${encodeURIComponent(filePath)}`;
                // Open in new tab
                window.open(githubUrl, '_blank');
                showNotification('üìã Opening in GitHub...', 'info');
            } catch (error) {
                console.error('Failed to open GitHub URL:', error);
                showNotification('‚ùå Failed to open GitHub URL', 'error');
            }
        }

        // Load file by path (for internal markdown links)
        async function loadFileByPath(filePath) {
            if (!filePath || typeof filePath !== 'string') {
                console.warn('loadFileByPath called with invalid filePath:', filePath);
                return;
            }
            
            console.log('Attempting to load file by path:', filePath);
            
            // Clean up the file path
            let cleanPath = filePath.replace(/^\.\//, '').replace(/^\//, '');
            
            // Try different matching strategies
            let file = null;
            
            // 1. Exact path match
            file = allFiles.find(f => f.path === cleanPath);
            
            // 2. Filename match (case insensitive)
            if (!file) {
                const filename = cleanPath.split('/').pop().toLowerCase();
                file = allFiles.find(f => f.name.toLowerCase() === filename);
            }
            
            // 3. Partial path match
            if (!file) {
                file = allFiles.find(f => f.path.toLowerCase().includes(cleanPath.toLowerCase()));
            }
            
            // 4. Just filename without extension
            if (!file) {
                const baseFilename = cleanPath.replace(/\.(md|pdf)$/i, '');
                file = allFiles.find(f => f.name.toLowerCase().includes(baseFilename.toLowerCase()));
            }
            
            if (file) {
                console.log('Found file:', file.path);
                await loadFile(file, file.category);
                showNotification(`üìÑ Navigated to: ${file.displayName}`, 'info');
            } else {
                console.log('File not found, available files:', allFiles.map(f => f.path));
                showNotification(`‚ùå File not found: ${filePath}`, 'warning');
                
                // Try to suggest similar files
                const suggestions = allFiles.filter(f => 
                    f.name.toLowerCase().includes(cleanPath.toLowerCase()) ||
                    cleanPath.toLowerCase().includes(f.name.toLowerCase().replace(/\.(md|pdf)$/i, ''))
                ).slice(0, 3);
                
                if (suggestions.length > 0) {
                    setTimeout(() => {
                        showNotification(`üí° Similar files: ${suggestions.map(f => f.displayName).join(', ')}`, 'info');
                    }, 2000);
                }
            }
        }

        // Render markdown to HTML
        function renderMarkdown(markdown, filePath = '') {
            if (!markdown || typeof markdown !== 'string') {
                console.warn('renderMarkdown called with invalid markdown:', markdown);
                return '<p>No content available</p>';
            }
            
            // Get the directory path for the current file to resolve relative images
            const fileDir = filePath ? filePath.substring(0, filePath.lastIndexOf('/')) : '';
            
            // Simple markdown parser - in production, use a library like marked.js
            let html = markdown
                // Headers
                .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                // Bold and italic
                .replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                // Code blocks with syntax highlighting (preserve line breaks)
                .replace(/```(\w+)?\n([\s\S]*?)```/g, (match, lang, code) => {
                    // Preserve line breaks and indentation in code blocks by protecting them
                    const cleanCode = code.trim();
                    return `<pre><code class="language-${lang || ''}">${cleanCode}</code></pre>`;
                })
                .replace(/```([\s\S]*?)```/g, (match, code) => {
                    // Preserve line breaks for code blocks without language
                    const cleanCode = code.trim();
                    return `<pre><code>${cleanCode}</code></pre>`;
                })
                .replace(/`([^`]+)`/g, '<code>$1</code>')
                // Process HTML img tags FIRST
                .replace(/<img([^>]*)\s+src=["']([^"']+)["']([^>]*)>/g, (match, beforeSrc, src, afterSrc) => {
                    // Extract alt text if present
                    const altMatch = match.match(/alt=["']([^"']*)["']/);
                    const alt = altMatch ? altMatch[1] : '';
                    
                    // Extract width/height if present
                    const widthMatch = match.match(/width=["']?([^"'\s>]+)["']?/);
                    const width = widthMatch ? widthMatch[1] : '';
                    
                    // Clean up the source path
                    let cleanSrc = src.replace(/%20/g, ' ').replace(/^\s+/, '');
                    cleanSrc = cleanSrc.replace(/^%[0-9a-fA-F]{2}/, '');
                    cleanSrc = cleanSrc.replace(/^[0-9a-fA-F]{32}\//, '');
                    
                    let absoluteSrc;
                    if (src.startsWith('http') || src.startsWith('//')) {
                        absoluteSrc = src;
                    } else {
                        // Construct GitHub raw URL for relative paths
                        if (cleanSrc.startsWith('./')) {
                            absoluteSrc = `${GITHUB_RAW_BASE}/${fileDir}/${cleanSrc.substring(2)}`;
                        } else if (cleanSrc.startsWith('../')) {
                            absoluteSrc = `${GITHUB_RAW_BASE}/${fileDir}/${cleanSrc}`;
                        } else if (cleanSrc.startsWith('images/')) {
                            absoluteSrc = `${GITHUB_RAW_BASE}/${fileDir}/${cleanSrc}`;
                        } else if (cleanSrc.includes('/')) {
                            absoluteSrc = `${GITHUB_RAW_BASE}/${fileDir}/${cleanSrc}`;
                        } else {
                            absoluteSrc = `${GITHUB_RAW_BASE}/${fileDir}/images/${cleanSrc}`;
                        }
                    }
                    
                    absoluteSrc = encodeURI(absoluteSrc);
                    
                    // Build style string
                    let style = 'max-width: 100%; height: auto; border-radius: 8px; margin: 16px 0;';
                    if (width) {
                        style += ` width: ${width}px;`;
                    }
                    
                    // Create fallback URLs for different possible locations
                    const categoryName = fileDir.split('/')[0];
                    const fallbackUrls = [];
                    
                    // Add standard image folder locations
                    fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/images/SD/${cleanSrc}`));
                    fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/images/Popular%20Diffusion%20models/${cleanSrc}`));
                    fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/images/VQVAE/${cleanSrc}`));
                    fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/images/What%20are%20Diffusion%20Models/${cleanSrc}`));
                    fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/images/style%20transfer/${cleanSrc}`));
                    
                    // Add document-specific folders with hash codes
                    fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/Stable%20diffusion%203%20c73bab85d94944edbb991761fe6b6d06/${cleanSrc}`));
                    fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/Diffusion%20models%20for%20video%20generation%204a81adda3eb6405cbe8db8685390307b/${cleanSrc}`));
                    fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/InstructPix2Pix%20Learning%20to%20Follow%20Image%20Editing%20I%20873196964e104d4aa1fae9a777fd37f4/${cleanSrc}`));
                    
                    return `<img src="${absoluteSrc}" alt="${alt}" style="${style}" onerror="tryFallbackImage(this, ${JSON.stringify(fallbackUrls)}, '${alt || cleanSrc}')" onload="this.nextElementSibling.style.display='none';"><div style="display: none; padding: 12px; background: var(--surface-color); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-secondary); text-align: center;">üì∑ Image not found: ${alt || cleanSrc}</div>`;
                    
                    return `<img src="${absoluteSrc}" alt="${alt}" style="${style}" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" onload="this.nextElementSibling.style.display='none';"><div style="display: none; padding: 12px; background: var(--surface-color); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-secondary); text-align: center;">üì∑ Image not found: ${alt || src}</div>`;
                })
                // Process markdown images SECOND
                .replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (match, alt, src) => {
                    // If it's already an absolute URL, keep it as is
                    if (src.startsWith('http') || src.startsWith('//')) {
                        return `<img src="${src}" alt="${alt}" style="max-width: 100%; height: auto; border-radius: 8px; margin: 16px 0;">`;
                    }
                    
                    // For relative paths, construct the GitHub raw URL
                    let absoluteSrc;
                    // Clean up the source path by removing encoded spaces and other issues
                    let cleanSrc = src.replace(/%20/g, ' ').replace(/^\s+/, '');
                    
                    // Debug logging for ASMK and FLAME images
                    if (src.toLowerCase().includes('asmk') || src.toLowerCase().includes('flame') || 
                        cleanSrc.toLowerCase().includes('asmk') || cleanSrc.toLowerCase().includes('flame')) {
                        console.log(`üñºÔ∏è Processing image:`, {
                            originalSrc: src,
                            cleanSrc: cleanSrc,
                            fileDir: fileDir
                        });
                    }
                    
                    // Fix malformed paths that start with encoded characters
                    cleanSrc = cleanSrc.replace(/^%[0-9a-fA-F]{2}/, '');
                    
                    // Store whether we detected ASMK/DPT specific files for fallback URLs
                    let isASMKorDPTFile = cleanSrc.includes('21c71bdab3cf80dfa08ed81f2119a8d8') || 
                                         cleanSrc.includes('fb6ac57f98b8478099d71c4b45d8a4a8') ||
                                         cleanSrc.toLowerCase().includes('asmk') || 
                                         cleanSrc.toLowerCase().includes('aggregated%20selective');
                    
                    // Remove any leading hash codes or encoded content (but less aggressively)
                    cleanSrc = cleanSrc.replace(/^[0-9a-fA-F]{32}\//, '');
                    
                    if (cleanSrc.startsWith('./')) {
                        // Remove ./ and combine with file directory
                        absoluteSrc = `${GITHUB_RAW_BASE}/${fileDir}/${cleanSrc.substring(2)}`;
                    } else if (cleanSrc.startsWith('../')) {
                        // Handle parent directory navigation
                        absoluteSrc = `${GITHUB_RAW_BASE}/${fileDir}/${cleanSrc}`;
                    } else if (cleanSrc.startsWith('images/')) {
                        // Images folder relative to current directory
                        absoluteSrc = `${GITHUB_RAW_BASE}/${fileDir}/${cleanSrc}`;
                    } else if (cleanSrc.includes('/')) {
                        // Path includes folders - construct relative to file directory
                        absoluteSrc = `${GITHUB_RAW_BASE}/${fileDir}/${cleanSrc}`;
                    } else {
                        // Just a filename - use default images directory
                        absoluteSrc = `${GITHUB_RAW_BASE}/${fileDir}/images/${cleanSrc}`;
                    }
                    
                    // Encode the final URL properly with full URI encoding
                    absoluteSrc = encodeURI(absoluteSrc);
                    
                    // Debug logging for final URL
                    if (src.toLowerCase().includes('asmk') || src.toLowerCase().includes('flame') || 
                        cleanSrc.toLowerCase().includes('asmk') || cleanSrc.toLowerCase().includes('flame')) {
                        console.log(`üîó Final URL constructed:`, absoluteSrc);
                    }
                    
                    // Create fallback URLs for different possible locations
                    const categoryName = fileDir.split('/')[0];
                    const fallbackUrls = [];
                    
                    // Add standard image folder locations
                    fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/images/SD/${cleanSrc}`));
                    fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/images/Popular%20Diffusion%20models/${cleanSrc}`));
                    fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/images/VQVAE/${cleanSrc}`));
                    fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/images/What%20are%20Diffusion%20Models/${cleanSrc}`));
                    fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/images/style%20transfer/${cleanSrc}`));
                    
                    // Add document-specific folders with hash codes
                    fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/Stable%20diffusion%203%20c73bab85d94944edbb991761fe6b6d06/${cleanSrc}`));
                    fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/Diffusion%20models%20for%20video%20generation%204a81adda3eb6405cbe8db8685390307b/${cleanSrc}`));
                    fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/InstructPix2Pix%20Learning%20to%20Follow%20Image%20Editing%20I%20873196964e104d4aa1fae9a777fd37f4/${cleanSrc}`));
                    
                    // Add specific folders for ASMK and DPT only when we detect these specific files
                    if (isASMKorDPTFile || fileDir.toLowerCase().includes('asmk') || fileDir.toLowerCase().includes('dpt')) {
                        fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/Aggregated%20Selective%20Match%20Kernels%20(asmk)%2021c71bdab3cf80dfa08ed81f2119a8d8/${cleanSrc}`));
                        fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/DPT%20Vision%20Transformers%20for%20Dense%20Prediction%20fb6ac57f98b8478099d71c4b45d8a4a8/${cleanSrc}`));
                        fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/MiDaS%20for%20Monocular%20Depth%20Estimation%20f3bc8fad76294dd58c257b259d2ba896/${cleanSrc}`));
                    }
                    
                    // Add additional fallback paths for ASMK/DPT files
                    if (isASMKorDPTFile) {
                        // Try with the current fileDir as base
                        fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${fileDir}/${cleanSrc}`));
                    }
                    
                    // Debug logging for fallback URLs
                    if (src.toLowerCase().includes('asmk') || src.toLowerCase().includes('flame') || 
                        cleanSrc.toLowerCase().includes('asmk') || cleanSrc.toLowerCase().includes('flame')) {
                        console.log(`üìã Fallback URLs:`, fallbackUrls);
                    }
                    
                    return `<img src="${absoluteSrc}" alt="${alt}" style="max-width: 100%; height: auto; border-radius: 8px; margin: 16px 0;" onerror="tryFallbackImage(this, ${JSON.stringify(fallbackUrls)}, '${alt || cleanSrc}')" onload="this.nextElementSibling.style.display='none';"><div style="display: none; padding: 12px; background: var(--surface-color); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-secondary); text-align: center;">üì∑ Image not found: ${alt || cleanSrc}</div>`;
                    
                    return `<img src="${absoluteSrc}" alt="${alt}" style="max-width: 100%; height: auto; border-radius: 8px; margin: 16px 0;" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" onload="this.nextElementSibling.style.display='none';"><div style="display: none; padding: 12px; background: var(--surface-color); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-secondary); text-align: center;">üì∑ Image not found: ${alt || src}</div>`;
                })
                // Process markdown links SECOND
                .replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, text, url) => {
                    // Check if this is actually an image that should have been processed as ![](url)
                    if (url.match(/\.(png|jpg|jpeg|gif|bmp|webp|svg)$/i)) {
                        // This is an image referenced as a link - convert to image
                        let absoluteSrc;
                        let cleanUrl = url.replace(/%20/g, ' ').replace(/^\s+/, '');
                        
                        // Debug logging for ASMK and FLAME images
                        if (url.toLowerCase().includes('asmk') || url.toLowerCase().includes('flame') || 
                            cleanUrl.toLowerCase().includes('asmk') || cleanUrl.toLowerCase().includes('flame')) {
                            console.log(`üñºÔ∏è Processing link image:`, {
                                originalUrl: url,
                                cleanUrl: cleanUrl,
                                fileDir: fileDir
                            });
                        }
                        
                        // Fix malformed paths that start with encoded characters
                        cleanUrl = cleanUrl.replace(/^%[0-9a-fA-F]{2}/, '');
                        
                        // Store whether we detected ASMK/DPT specific files for fallback URLs
                        let isASMKorDPTUrl = cleanUrl.includes('21c71bdab3cf80dfa08ed81f2119a8d8') || 
                                            cleanUrl.includes('fb6ac57f98b8478099d71c4b45d8a4a8') ||
                                            cleanUrl.toLowerCase().includes('asmk') || 
                                            cleanUrl.toLowerCase().includes('aggregated%20selective');
                        
                        // Remove any leading hash codes or encoded content (but less aggressively)
                        cleanUrl = cleanUrl.replace(/^[0-9a-fA-F]{32}\//, '');
                        
                        if (cleanUrl.startsWith('http') || cleanUrl.startsWith('//')) {
                            absoluteSrc = cleanUrl;
                        } else if (cleanUrl.startsWith('./')) {
                            absoluteSrc = `${GITHUB_RAW_BASE}/${fileDir}/${cleanUrl.substring(2)}`;
                        } else if (cleanUrl.startsWith('images/')) {
                            absoluteSrc = `${GITHUB_RAW_BASE}/${fileDir}/${cleanUrl}`;
                        } else if (cleanUrl.includes('/')) {
                            absoluteSrc = `${GITHUB_RAW_BASE}/${fileDir}/${cleanUrl}`;
                        } else {
                            absoluteSrc = `${GITHUB_RAW_BASE}/${fileDir}/images/${cleanUrl}`;
                        }
                        
                        // Encode the final URL properly
                        absoluteSrc = encodeURI(absoluteSrc);
                        
                        // Create fallback URLs for different possible locations
                        const categoryName = fileDir.split('/')[0];
                        const fallbackUrls = [];
                        
                        // Add standard image folder locations
                        fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/images/SD/${cleanUrl}`));
                        fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/images/Popular%20Diffusion%20models/${cleanUrl}`));
                        fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/images/VQVAE/${cleanUrl}`));
                        fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/images/What%20are%20Diffusion%20Models/${cleanUrl}`));
                        fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/images/style%20transfer/${cleanUrl}`));
                        
                        // Add document-specific folders with hash codes
                        fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/Stable%20diffusion%203%20c73bab85d94944edbb991761fe6b6d06/${cleanUrl}`));
                        fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/Diffusion%20models%20for%20video%20generation%204a81adda3eb6405cbe8db8685390307b/${cleanUrl}`));
                        fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/InstructPix2Pix%20Learning%20to%20Follow%20Image%20Editing%20I%20873196964e104d4aa1fae9a777fd37f4/${cleanUrl}`));
                        
                        // Add specific folders for ASMK and DPT only when we detect these specific files
                        if (isASMKorDPTUrl || fileDir.toLowerCase().includes('asmk') || fileDir.toLowerCase().includes('dpt')) {
                            fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/Aggregated%20Selective%20Match%20Kernels%20(asmk)%2021c71bdab3cf80dfa08ed81f2119a8d8/${cleanUrl}`));
                            fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/DPT%20Vision%20Transformers%20for%20Dense%20Prediction%20fb6ac57f98b8478099d71c4b45d8a4a8/${cleanUrl}`));
                            fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${categoryName}/MiDaS%20for%20Monocular%20Depth%20Estimation%20f3bc8fad76294dd58c257b259d2ba896/${cleanUrl}`));
                        }
                        
                        // Add additional fallback paths for ASMK/DPT files
                        if (isASMKorDPTUrl) {
                            // Try with the current fileDir as base
                            fallbackUrls.push(encodeURI(`${GITHUB_RAW_BASE}/${fileDir}/${cleanUrl}`));
                        }
                        
                        return `<img src="${absoluteSrc}" alt="${text}" style="max-width: 100%; height: auto; border-radius: 8px; margin: 16px 0;" onerror="tryFallbackImage(this, ${JSON.stringify(fallbackUrls)}, '${text}')" onload="this.nextElementSibling.style.display='none';"><div style="display: none; padding: 12px; background: var(--surface-color); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-secondary); text-align: center;">üì∑ Image not found: ${text}</div>`;
                        
                        return `<img src="${absoluteSrc}" alt="${text}" style="max-width: 100%; height: auto; border-radius: 8px; margin: 16px 0;" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" onload="this.nextElementSibling.style.display='none';"><div style="display: none; padding: 12px; background: var(--surface-color); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-secondary); text-align: center;">üì∑ Image not found: ${text}</div>`;
                    }
                    
                    // Handle different types of links
                    if (url.startsWith('http') || url.startsWith('//')) {
                        // External link - open in new tab
                        return `<a href="${url}" target="_blank">${text}</a>`;
                    } else if (url.endsWith('.md')) {
                        // Internal markdown file link
                        const cleanUrl = url.replace(/^\.\//, ''); // Remove leading ./
                        return `<a href="#" onclick="loadFileByPath('${cleanUrl}'); return false;">${text}</a>`;
                    } else if (url.endsWith('.pdf')) {
                        // PDF link - open in new tab
                        const absoluteUrl = url.startsWith('http') ? url : `${GITHUB_RAW_BASE}/${fileDir}/${url}`;
                        return `<a href="${absoluteUrl}" target="_blank">${text} üìã</a>`;
                    } else if (url.startsWith('#')) {
                        // Anchor link within same document
                        return `<a href="${url}">${text}</a>`;
                    } else {
                        // Other relative links - treat as external
                        return `<a href="${url}" target="_blank">${text}</a>`;
                    }
                })
                // Convert arxiv links FIRST (both with and without https://)
                .replace(/(^|[^[\(<a])(https?:\/\/)?(arxiv\.org\/abs\/[\d\.]+)/g, (match, prefix, protocol, path) => {
                    // Only show the arxiv.org/abs/... part, not the full URL
                    const url = protocol ? `${protocol}${path}` : `https://${path}`;
                    return `${prefix}<a href="${url}" target="_blank">${path}</a>`;
                })
                // Process other plain URLs LAST (but skip arxiv URLs)
                .replace(/(^|[^"'=\/>])(https?:\/\/[^\s<>"\],]+)/g, (match, prefix, url) => {
                    // Skip if this URL is already processed or contains arxiv
                    if (match.includes('href=') || match.includes('src=') || match.includes('target=') || url.includes('arxiv.org')) {
                        return match;
                    }
                    // Clean up URL (remove trailing punctuation)
                    const cleanUrl = url.replace(/[.,;!?]+$/, '');
                    return `${prefix}<a href="${cleanUrl}" target="_blank">${cleanUrl}</a>`;
                })
                // Convert DOI patterns
                .replace(/(^|[^[\(<a])(doi:[\w\.\/\-]+)/g, (match, prefix, doi) => {
                    const url = `https://doi.org/${doi.replace('doi:', '')}`;
                    return `${prefix}<a href="${url}" target="_blank">${doi}</a>`;
                })
                // Lists
                .replace(/^\* (.+)$/gim, '<li>$1</li>')
                .replace(/^- (.+)$/gim, '<li>$1</li>')
                .replace(/^\d+\. (.+)$/gim, '<li>$1</li>')
                // Tables - simple and reliable processing
                .replace(/\|(.+)\|/g, (match, content) => {
                    const cells = content.split('|').map(cell => cell.trim()).filter(cell => cell.length > 0);
                    if (cells.length === 0) return match;
                    
                    // Check if this is a separator row (contains only - and |)
                    if (cells.every(cell => /^[-:\s]+$/.test(cell))) {
                        return ''; // Remove separator rows
                    }
                    
                    const cellTags = cells.map(cell => `<td>${cell}</td>`).join('');
                    return `<tr>${cellTags}</tr>`;
                })
                // Line breaks (but preserve code block formatting)
                .replace(/\n\n/g, '</p><p>');
            
            // Apply line breaks only outside of code blocks
            html = html.replace(/\n/g, (match, offset, string) => {
                // Check if we're inside a <pre><code> block
                const beforeMatch = string.substring(0, offset);
                const openTags = (beforeMatch.match(/<pre><code/g) || []).length;
                const closeTags = (beforeMatch.match(/<\/code><\/pre>/g) || []).length;
                
                // If we're inside a code block, preserve the newline as is
                if (openTags > closeTags) {
                    return '\n';
                }
                // Otherwise convert to <br>
                return '<br>';
            });
            
            // Wrap in paragraphs
            html = '<p>' + html + '</p>';
            
            // Clean up
            html = html
                .replace(/<p><\/p>/g, '')
                .replace(/<p>(<h[1-6]>)/g, '$1')
                .replace(/(<\/h[1-6]>)<\/p>/g, '$1')
                .replace(/<p>(<pre>)/g, '$1')
                .replace(/(<\/pre>)<\/p>/g, '$1')
                .replace(/<p>(<img)/g, '$1')
                .replace(/(\/div>)<\/p>/g, '$1')
                .replace(/<br><li>/g, '<li>')
                .replace(/<\/li><br>/g, '</li>')
                .replace(/<p>(<tr>)/g, '$1')
                .replace(/(<\/tr>)<\/p>/g, '$1');
            
            // Wrap lists
            html = html.replace(/(<li>.*?<\/li>)/gs, '<ul>$1</ul>');
            
            // Wrap tables - simplified approach
            html = html.replace(/(<tr>.*?<\/tr>(?:\s*<br>\s*<tr>.*?<\/tr>)*)/gs, (match) => {
                // Extract all <tr> elements from the match
                const rows = match.match(/<tr>.*?<\/tr>/gs);
                if (!rows || rows.length === 0) return match;
                
                // First row becomes header, rest become body
                const headerRow = rows[0].replace(/<td>/g, '<th>').replace(/<\/td>/g, '</th>');
                const bodyRows = rows.slice(1).join('');
                
                if (bodyRows.length > 0) {
                    return `<table><thead>${headerRow}</thead><tbody>${bodyRows}</tbody></table>`;
                } else {
                    return `<table><thead>${headerRow}</thead></table>`;
                }
            });
            
            return html;
        }

        // Set active file in sidebar
        function setActiveFile(filePath) {
            // Remove previous active states
            document.querySelectorAll('.file-item.active').forEach(item => {
                item.classList.remove('active');
            });
            
            // Find and activate current file
            const fileItems = document.querySelectorAll('.file-item');
            fileItems.forEach(item => {
                if (item.onclick.toString().includes(filePath)) {
                    item.classList.add('active');
                }
            });
        }

        // Show welcome screen
        async function fetchRecentCommits() {
            try {
                console.log('üîç Fetching recent commits from GitHub API...');
                const response = await createGitHubRequest(`${GITHUB_API_BASE}/commits?per_page=50`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch commits: ${response.status}`);
                }
                
                const commits = await response.json();
                console.log(`üìä Recent commits fetched: ${commits.length}`);
                
                // Extract files from recent commits and get the most recent update for each file
                const fileUpdateMap = new Map();
                
                // Process commits in parallel for speed
                const commitPromises = commits.slice(0, 20).map(async (commit) => {
                    try {
                        const commitResponse = await createGitHubRequest(commit.url);
                        if (commitResponse.ok) {
                            const commitDetails = await commitResponse.json();
                            
                            if (commitDetails.files) {
                                return commitDetails.files
                                    .filter(file => {
                                        const filename = file.filename.toLowerCase();
                                        return (filename.endsWith('.md') || filename.endsWith('.pdf')) && 
                                               !filename.includes('readme') &&
                                               !filename.endsWith('readme.txt') &&
                                               !filename.endsWith('readme.md') &&
                                               !fileUpdateMap.has(file.filename);
                                    })
                                    .map(file => ({
                                        path: file.filename,
                                        lastModified: commit.commit.committer.date,
                                        commitMessage: commit.commit.message,
                                        status: file.status,
                                        commitSha: commit.sha
                                    }));
                            }
                        }
                    } catch (error) {
                        console.log('Error fetching commit details:', error);
                        return [];
                    }
                    return [];
                });
                
                // Wait for all commit details
                const allFiles = await Promise.all(commitPromises);
                
                // Flatten and add to map
                allFiles.flat().forEach(file => {
                    if (file && !fileUpdateMap.has(file.path)) {
                        // Log specific files for debugging
                        if (file.path.toLowerCase().includes('dust3r') || 
                            file.path.toLowerCase().includes('mast3r') || 
                            file.path.toLowerCase().includes('asmk') ||
                            file.path.toLowerCase().includes('flame')) {
                            console.log(`üéØ Found target file: ${file.path}, committed: ${file.lastModified}`);
                        }
                        
                        fileUpdateMap.set(file.path, file);
                    }
                });
                
                const recentFiles = Array.from(fileUpdateMap.values())
                    .sort((a, b) => new Date(b.lastModified) - new Date(a.lastModified))
                    .slice(0, 3);
                
                console.log('üìã Top 3 most recent files found:');
                recentFiles.forEach((file, index) => {
                    console.log(`${index + 1}. ${file.path} - ${file.lastModified}`);
                });
                
                return recentFiles;
                    
            } catch (error) {
                console.error('‚ùå Failed to fetch recent commits:', error);
                return [];
            }
        }

        async function updateRecentFilesFromCommits(commitFiles) {
            console.log('üîÑ Updating recent files from commit data...');
            
            // Map commit files to the recentFiles format
            const mappedFiles = [];
            
            for (const commitFile of commitFiles) {
                // Find the file in our repository data to get display info
                let fileInfo = null;
                let category = '';
                let categoryDisplayName = '';
                
                // Search through all categories to find this file
                for (const [catKey, catData] of Object.entries(repositoryData)) {
                    const found = catData.files.find(f => 
                        f.path === commitFile.path || 
                        f.path.endsWith(commitFile.path) ||
                        commitFile.path.endsWith(f.name)
                    );
                    if (found) {
                        fileInfo = found;
                        category = catKey;
                        categoryDisplayName = catData.displayName;
                        break;
                    }
                }
                
                // If not found in repository data, create basic info from commit data
                if (!fileInfo) {
                    const fileName = commitFile.path.split('/').pop();
                    const cleanName = fileName.replace(/\.md$/, '')
                        .replace(/[_-]/g, ' ')
                        .replace(/([Ôºö:])([^\s])/g, '$1 $2'); // Add space after colons if missing
                    
                    // Try to determine category from path
                    if (commitFile.path.toLowerCase().includes('3d') || 
                        commitFile.path.toLowerCase().includes('dust3r') || 
                        commitFile.path.toLowerCase().includes('mast3r') ||
                        commitFile.path.toLowerCase().includes('flame')) {
                        category = '3D reconstruction';
                        categoryDisplayName = '3D Reconstruction';
                    } else if (commitFile.path.toLowerCase().includes('matching') || 
                               commitFile.path.toLowerCase().includes('asmk')) {
                        category = 'Matching&tracking';
                        categoryDisplayName = 'Matching & Tracking';
                    } else if (commitFile.path.toLowerCase().includes('transformer')) {
                        category = 'Transformers&beyond';
                        categoryDisplayName = 'Transformers & Beyond';
                    } else {
                        category = 'General';
                        categoryDisplayName = 'General';
                    }
                    
                    fileInfo = {
                        name: fileName,
                        displayName: cleanName,
                        path: commitFile.path.replace(/\/+$/, ''), // Remove trailing slashes
                        type: 'markdown',
                        downloadUrl: `${GITHUB_RAW_BASE}/${encodeURIComponent(commitFile.path.replace(/\/+$/, '')).replace(/%2F/g, '/')}`
                    };
                }
                
                // Create summary based on file name
                let summary = '';
                const displayName = fileInfo.displayName.toLowerCase();
                if (displayName.includes('dust3r')) {
                    summary = 'Revolutionary 3D reconstruction using neural radiance fields';
                } else if (displayName.includes('mast3r')) {
                    summary = 'Advanced matching and 3D reconstruction pipeline';
                } else if (displayName.includes('asmk')) {
                    summary = 'Aggregated Selective Match Kernels for image retrieval';
                } else if (displayName.includes('flame')) {
                    summary = 'Faces Learned with an Articulated Model and Expressions';
                } else if (displayName.includes('flash attention')) {
                    summary = 'Memory-efficient attention mechanism for transformers';
                } else if (displayName.includes('mamba')) {
                    summary = 'Linear-time sequence modeling with state spaces';
                } else {
                    summary = categoryDisplayName + ' research and implementation';
                }
                
                mappedFiles.push({
                    name: fileInfo.name,
                    path: fileInfo.path.replace(/\/+$/, ''), // Remove trailing slashes
                    displayName: fileInfo.displayName,
                    summary: summary,
                    category: category,
                    categoryDisplayName: categoryDisplayName,
                    type: fileInfo.type,
                    downloadUrl: fileInfo.downloadUrl,
                    timestamp: new Date(commitFile.lastModified).getTime(),
                    commitMessage: commitFile.commitMessage,
                    commitSha: commitFile.commitSha
                });
            }
            
            // Update the global recentFiles array
            recentFiles = mappedFiles;
            
            // Save to localStorage
            localStorage.setItem('ai-journal-recent', JSON.stringify(recentFiles));
            
            console.log('‚úÖ Updated recent files with commit data:', recentFiles.length);
            recentFiles.forEach((file, index) => {
                console.log(`${index + 1}. ${file.displayName} - ${new Date(file.timestamp).toLocaleDateString()}`);
            });
        }

        async function generateRecentUpdatesList() {
            // Clear any cached data to ensure fresh API calls
            localStorage.removeItem('ai-journal-cached-data');
            
            // First try to get real commit data
            try {
                console.log('üîÑ Fetching real recent commits for recent updates...');
                const recentCommitFiles = await fetchRecentCommits();
                
                if (recentCommitFiles && recentCommitFiles.length > 0) {
                    console.log('‚úÖ Found recent commit files:', recentCommitFiles.length);
                    await updateRecentFilesFromCommits(recentCommitFiles);
                    showFallbackRecentFiles(); // This will now use the updated recentFiles array
                } else {
                    console.log('‚ö†Ô∏è No recent commit files found, using fallback');
                    showFallbackRecentFiles();
                }
            } catch (error) {
                console.log('‚ùå Failed to fetch recent commits, using fallback:', error);
                showFallbackRecentFiles();
            }
            
            // Don't return placeholder text - let showFallbackRecentFiles handle the display
            return '';
        }

        function updateRecentUpdatesDisplay(recentFiles) {
            const categoryIcons = {
                '3D reconstruction': 'üèóÔ∏è',
                'CNN_DL': 'üß†',
                'Diffusion_models_GAN': 'üé®',
                'Generative AI': '‚ú®',
                'LLM': 'üó£Ô∏è',
                'LoRA': 'üîß',
                'Transformers&beyond': 'üîÄ',
                'computer vision': 'üëÅÔ∏è',
                'multimodal': 'üîÑ',
                'optimization': '‚ö°',
                'retrieval': 'üîç',
                'video': 'üé¨'
            };

            const recentUpdatesList = document.getElementById('recentUpdatesList');
            if (recentUpdatesList) {
                const html = recentFiles.map(file => {
                    const timeAgo = getTimeAgo(new Date(file.lastModified));
                    const category = file.path.split('/')[0];
                    const icon = categoryIcons[category] || 'üìÑ';
                    const fileName = file.path.split('/').pop().replace('.md', '').replace('.pdf', '');
                    const displayName = formatFileDisplayName(fileName);
                    
                    return `
                        <div class="recent-file-item" onclick="loadFileByPath('${file.path}')">
                            <div class="recent-file-content">
                                <div class="recent-file-title">${icon} ${displayName}</div>
                                <div class="recent-file-meta">
                                    <span>üìÅ ${formatDisplayName(category)}</span>
                                    <span>‚è±Ô∏è Updated ${timeAgo}</span>
                                </div>
                            </div>
                            <div class="recent-file-type">MARKDOWN</div>
                        </div>
                    `;
                }).join('');
                
                recentUpdatesList.innerHTML = html;
            }
        }

        function showFallbackRecentFiles() {
            const recentUpdatesList = document.getElementById('recentUpdatesList');
            if (!recentUpdatesList) return;
            
            console.log('üìö Showing fallback recent files, recentFiles.length:', recentFiles.length);
            
            if (recentFiles.length === 0) {
                recentUpdatesList.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 20px;">No recent files available</p>';
                return;
            }
            
            // Use the recent files data to show recent updates
            const recentFilesToShow = recentFiles.slice(0, 3); // Show top 3 for cleaner look
            
            // Clear existing content first
            recentUpdatesList.innerHTML = '';
            
            recentFilesToShow.forEach(file => {
                // Calculate time ago from timestamp
                const timeAgo = formatTimeAgo(file.timestamp);
                const categoryIcon = getCategoryIcon(file.category);
                
                const recentItem = document.createElement('div');
                recentItem.className = 'recent-file-item'; // Use existing CSS class
                recentItem.onclick = () => {
                    console.log('üéØ Recent update clicked:', file);
                    loadFile(file, file.category);
                };
                
                recentItem.innerHTML = `
                    <div class="recent-file-content">
                        <div class="recent-file-title">${categoryIcon} ${sanitizeForDOM(file.displayName)}</div>
                        <div class="recent-file-meta">
                            <span>${sanitizeForDOM(file.summary || file.categoryDisplayName)}</span>
                            <span class="recent-file-type">${file.categoryDisplayName}</span>
                        </div>
                    </div>
                    <div class="update-time" style="font-size: 12px; color: var(--text-secondary); font-weight: 500;">${timeAgo}</div>
                `;
                
                recentUpdatesList.appendChild(recentItem);
            });
            
            console.log('‚úÖ Fallback recent files displayed');
        }
        
        // Helper function to format time ago
        function formatTimeAgo(timestamp) {
            const now = Date.now();
            const diff = now - timestamp;
            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const hours = Math.floor(diff / (1000 * 60 * 60));
            const minutes = Math.floor(diff / (1000 * 60));
            
            if (days > 0) {
                return `${days} day${days > 1 ? 's' : ''} ago`;
            } else if (hours > 0) {
                return `${hours} hour${hours > 1 ? 's' : ''} ago`;
            } else if (minutes > 0) {
                return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
            } else {
                return 'Just now';
            }
        }
        
        function getCategoryIcon(category) {
            const categoryIcons = {
                '3D reconstruction': 'üéØ',
                'CNN_DL': 'üß†',
                'Diffusion_models_GAN': 'üé®',
                'Generative AI': '‚ú®',
                'LLM': 'üí¨',
                'MDE': 'üìè',
                'Matching&tracking': 'üîç',
                'Tools_Usage': 'üõ†Ô∏è',
                'Transformers&beyond': 'üîÄ',
                'VO_VIO_VSLAM': 'üìç'
            };
            return categoryIcons[category] || 'üìÑ';
        }

        function getTimeAgo(date) {
            const now = new Date();
            const diffTime = Math.abs(now - date);
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            
            if (diffDays === 0) return 'today';
            if (diffDays === 1) return 'yesterday';
            if (diffDays < 7) return `${diffDays} days ago`;
            if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
            return `${Math.floor(diffDays / 30)} months ago`;
        }

        function showWelcome() {
            const contentHeader = document.getElementById('contentHeader');
            const contentBody = document.getElementById('contentBody');
            
            contentHeader.style.display = 'none';
            contentBody.innerHTML = `
                <div class="welcome-content">
                    <h1 class="welcome-title">AI Learning Journal</h1>
                    <p class="welcome-subtitle">Comprehensive documentation and research notes on artificial intelligence, machine learning, and computer vision</p>
                    
                    <div class="welcome-stats">
                        <div class="stat-card">
                            <div class="stat-value" id="totalFiles">${allFiles.length}</div>
                            <div class="stat-label">Total Files</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="totalCategories">${Object.keys(repositoryData).length}</div>
                            <div class="stat-label">Categories</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="readFiles">${readFiles.length}</div>
                            <div class="stat-label">Files Read</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="favoriteCount">${favorites.length}</div>
                            <div class="stat-label">Favorites</div>
                        </div>
                    </div>

                    <div class="recent-updates">
                        <h2 class="section-title">üìù Recent Updates</h2>
                        <div class="recent-files-list" id="recentUpdatesList">
                            <div style="text-align: center; padding: 20px; color: var(--text-secondary);">üîÑ Loading recent updates...</div>
                        </div>
                    </div>

                    <div class="quick-access">
                        <div class="quick-access-item" onclick="expandFolder('3D reconstruction')">
                            <div class="quick-access-icon">üèóÔ∏è</div>
                            <div class="quick-access-title">3D Reconstruction</div>
                            <div class="quick-access-desc">NeRF, Gaussian Splatting, and 3D vision techniques</div>
                        </div>
                        <div class="quick-access-item" onclick="expandFolder('LLM')">
                            <div class="quick-access-icon">üó£Ô∏è</div>
                            <div class="quick-access-title">Large Language Models</div>
                            <div class="quick-access-desc">GPT, LLaMA, and language model research</div>
                        </div>
                        <div class="quick-access-item" onclick="expandFolder('Diffusion_models_GAN')">
                            <div class="quick-access-icon">üé®</div>
                            <div class="quick-access-title">Generative Models</div>
                            <div class="quick-access-desc">Diffusion models, GANs, and image generation</div>
                        </div>
                    </div>
                </div>
            `;
            
            // Remove active file states
            document.querySelectorAll('.file-item.active').forEach(item => {
                item.classList.remove('active');
            });
            
            currentFile = null;
            
            // Ensure stats are updated with current values after welcome screen is shown
            updateStats();
            
            // Populate the recent files section now that the welcome screen is ready
            generateRecentUpdatesList();
        }

        // Search functionality
        let searchTimeout;
        function handleSearch(query) {
            clearTimeout(searchTimeout);
            
            if (query.length < 2) {
                hideSearchResults();
                return;
            }
            
            searchTimeout = setTimeout(() => {
                performSearch(query);
            }, 300);
        }

        function performSearch(query) {
            const results = allFiles.filter(file => 
                file.displayName.toLowerCase().includes(query.toLowerCase()) ||
                file.categoryDisplayName.toLowerCase().includes(query.toLowerCase())
            ).slice(0, 10);
            
            displaySearchResults(results, query);
        }

        function displaySearchResults(results, query) {
            const searchResults = document.getElementById('searchResults');
            
            if (results.length === 0) {
                searchResults.innerHTML = '<div class="search-result-item">No results found</div>';
            } else {
                searchResults.innerHTML = results.map(file => `
                    <div class="search-result-item" onclick="selectSearchResult('${file.path}', '${file.category}')">
                        <div class="search-result-title">${highlightQuery(file.displayName, query)}</div>
                        <div class="search-result-path">${file.categoryDisplayName}</div>
                        <div class="search-result-snippet">${file.type === 'markdown' ? 'Markdown' : 'PDF'} ‚Ä¢ ${formatFileSize(file.size || 0)}</div>
                    </div>
                `).join('');
            }
            
            searchResults.style.display = 'block';
        }

        function highlightQuery(text, query) {
            const regex = new RegExp(`(${escapeRegex(query)})`, 'gi');
            return text.replace(regex, '<span class="search-highlight">$1</span>');
        }

        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function selectSearchResult(filePath, categoryName) {
            const file = allFiles.find(f => f.path === filePath);
            if (file) {
                loadFile(file, categoryName);
                hideSearchResults();
                document.querySelector('.search-input').value = '';
            }
        }

        function showSearchResults() {
            const query = document.querySelector('.search-input').value;
            if (query.length >= 2) {
                performSearch(query);
            }
        }

        function hideSearchResults() {
            setTimeout(() => {
                document.getElementById('searchResults').style.display = 'none';
            }, 200);
        }

        // Favorites management
        function toggleFavorite(filePath) {
            const index = favorites.indexOf(filePath);
            if (index === -1) {
                favorites.push(filePath);
            } else {
                favorites.splice(index, 1);
            }
            
            localStorage.setItem('ai-journal-favorites', JSON.stringify(favorites));
            updateFavoriteIcons();
            renderFavoriteFiles();
            updateStats();
        }

        function updateFavoriteIcons() {
            document.querySelectorAll('.favorite-icon').forEach(icon => {
                const filePath = icon.getAttribute('onclick').match(/'([^']+)'/)[1];
                icon.classList.toggle('active', favorites.includes(filePath));
            });
        }

        function renderFavoriteFiles() {
            const favoriteFiles = document.getElementById('favoriteFiles');
            const favoriteFilesList = allFiles.filter(file => favorites.includes(file.path));
            
            if (favoriteFilesList.length === 0) {
                favoriteFiles.innerHTML = '<div style="color: var(--text-secondary); font-size: 14px; padding: 8px;">No favorites yet</div>';
            } else {
                favoriteFiles.innerHTML = favoriteFilesList.map(file => `
                    <div class="file-item" onclick="loadFile(${JSON.stringify(file).replace(/"/g, '&quot;')}, '${file.category}')">
                        <span class="file-icon">${file.type === 'markdown' ? 'üìÑ' : 'üìã'}</span>
                        <span class="file-name">${file.displayName}</span>
                    </div>
                `).join('');
            }
        }

        // Recent files management
        function addToRecentFiles(file, categoryName) {
            const fileWithCategory = { ...file, category: categoryName };
            const existingIndex = recentFiles.findIndex(f => f.path === file.path);
            
            if (existingIndex !== -1) {
                recentFiles.splice(existingIndex, 1);
            }
            
            recentFiles.unshift(fileWithCategory);
            recentFiles = recentFiles.slice(0, 10); // Keep only 10 recent files
            
            localStorage.setItem('ai-journal-recent', JSON.stringify(recentFiles));
            renderRecentFiles();
        }

        function renderRecentFiles() {
            console.log('üïí renderRecentFiles called, recentFiles.length:', recentFiles.length);
            const recentFilesElement = document.getElementById('recentFiles');
            
            if (!recentFilesElement) {
                console.error('‚ùå recentFiles element not found!');
                return;
            }
            
            if (recentFiles.length === 0) {
                console.log('‚ö†Ô∏è No recent files to display');
                recentFilesElement.innerHTML = '<div style="color: var(--text-secondary); font-size: 14px; padding: 8px;">No recent files</div>';
            } else {
                console.log('üìÑ Rendering', recentFiles.length, 'recent files');
                recentFilesElement.innerHTML = '';
                
                recentFiles.forEach((file, index) => {
                    console.log(`üîç Processing recent file ${index + 1}:`, file);
                    
                    const fileDiv = document.createElement('div');
                    fileDiv.className = 'file-item';
                    fileDiv.onclick = () => {
                        console.log('üéØ Recent file clicked:', file);
                        loadFile(file, file.category);
                    };
                    
                    const icon = file.type === 'markdown' ? 'üìÑ' : 'üìã';
                    const sanitizedDisplayName = sanitizeForDOM(file.displayName);
                    
                    fileDiv.innerHTML = `
                        <span class="file-icon">${icon}</span>
                        <span class="file-name">${sanitizedDisplayName}</span>
                    `;
                    
                    recentFilesElement.appendChild(fileDiv);
                    console.log(`‚úÖ Added recent file ${index + 1}:`, sanitizedDisplayName);
                });
            }
        }

        // Reading progress
        function markAsRead(filePath) {
            if (!readFiles.includes(filePath)) {
                readFiles.push(filePath);
                localStorage.setItem('ai-journal-read', JSON.stringify(readFiles));
                updateStats();
            }
        }

        // Update statistics
        function updateStats() {
            console.log('üìä Updating stats:', {
                totalFiles: allFiles.length,
                totalCategories: Object.keys(repositoryData).length,
                readFiles: readFiles.length,
                favorites: favorites.length
            });
            
            const totalFilesEl = document.getElementById('totalFiles');
            const totalCategoriesEl = document.getElementById('totalCategories');
            const readFilesEl = document.getElementById('readFiles');
            const favoriteCountEl = document.getElementById('favoriteCount');
            
            if (totalFilesEl) totalFilesEl.textContent = allFiles.length;
            if (totalCategoriesEl) totalCategoriesEl.textContent = Object.keys(repositoryData).length;
            if (readFilesEl) readFilesEl.textContent = readFiles.length;
            if (favoriteCountEl) favoriteCountEl.textContent = favorites.length;
            
            console.log('‚úÖ Stats updated successfully');
        }

        // Theme management
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            document.getElementById('themeIcon').textContent = newTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
            
            localStorage.setItem('ai-journal-theme', newTheme);
        }

        // GitHub Token Management
        function showGitHubTokenDialog() {
            const currentToken = localStorage.getItem('github-token') || '';
            const tokenValue = prompt(
                `üîë GitHub Personal Access Token (Optional)\n\n` +
                `This increases your API rate limit from 60 to 5,000 requests/hour.\n\n` +
                `To create a token:\n` +
                `1. Go to GitHub.com ‚Üí Settings ‚Üí Developer settings\n` +
                `2. Personal access tokens ‚Üí Generate new token\n` +
                `3. Only needs 'public_repo' permission\n` +
                `4. Copy and paste the token below\n\n` +
                `Leave empty to remove existing token:`,
                currentToken
            );
            
            if (tokenValue !== null) {
                if (tokenValue.trim()) {
                    localStorage.setItem('github-token', tokenValue.trim());
                    showNotification('üîë GitHub token saved! Refresh to use higher rate limit.', 'success');
                } else {
                    localStorage.removeItem('github-token');
                    showNotification('üîë GitHub token removed.', 'info');
                }
            }
        }

        // Mobile sidebar toggle
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.getElementById('mainContent');
            
            sidebar.classList.toggle('open');
            mainContent.classList.toggle('sidebar-collapsed');
        }

        // Utility functions
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        function showLoading(message = 'Loading...') {
            const contentBody = document.getElementById('contentBody');
            contentBody.classList.add('loading');
            contentBody.innerHTML = `<div class="loading">${message}</div>`;
        }
        
        function hideLoading() {
            const contentBody = document.getElementById('contentBody');
            contentBody.classList.remove('loading');
            const loadingElement = contentBody.querySelector('.loading');
            if (loadingElement) {
                loadingElement.remove();
            }
        }

        function showError(message) {
            const contentBody = document.getElementById('contentBody');
            contentBody.innerHTML = `
                <div class="error">
                    <div class="error-title">Error</div>
                    <div>${message}</div>
                </div>
            `;
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: ${type === 'warning' ? '#f59e0b' : 'var(--primary-color)'};
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                box-shadow: var(--shadow-lg);
                z-index: 2000;
                font-size: 14px;
                max-width: 300px;
            `;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 5000);
        }

        // Initialize theme
        function initializeTheme() {
            const savedTheme = localStorage.getItem('ai-journal-theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            document.getElementById('themeIcon').textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        }

        // Handle URL hash navigation
        function handleHashNavigation() {
            const hash = window.location.hash.substring(1); // Remove #
            if (hash && hash.startsWith('file:')) {
                const filePath = decodeURIComponent(hash.substring(5)); // Remove 'file:'
                setTimeout(() => {
                    loadFileByPath(filePath);
                }, 1000); // Wait for app to initialize
            }
        }

        // Update URL when navigating to a file
        function updateUrlHash(filePath) {
            console.log('üîó updateUrlHash called with filePath:', JSON.stringify(filePath));
            // Clean the file path by removing trailing slashes
            const cleanedPath = filePath.replace(/\/+$/, '');
            console.log('üßπ Cleaned path:', JSON.stringify(cleanedPath));
            const encoded = encodeURIComponent(cleanedPath);
            const newHash = `#file:${encoded}`;
            console.log('üîó Final hash:', newHash);
            history.pushState(null, null, newHash);
        }

        // Real-time update system
        let updateInterval = null;
        let lastCommitSha = null;
        
        function startRealtimeUpdates() {
            const hasToken = !!localStorage.getItem('github-token');
            const updateFrequency = hasToken ? 2 * 60 * 1000 : 10 * 60 * 1000; // 2min with token, 10min without
            
            console.log(`üîÑ Starting real-time updates every ${updateFrequency/1000/60} minutes (Token: ${hasToken ? 'Yes' : 'No'})`);
            
            if (updateInterval) {
                clearInterval(updateInterval);
            }
            
            updateInterval = setInterval(async () => {
                await checkForNewCommits();
            }, updateFrequency);
        }
        
        function stopRealtimeUpdates() {
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
                console.log('‚èπÔ∏è Stopped real-time updates');
            }
        }
        
        async function checkForNewCommits() {
            try {
                console.log('üîç Checking for new commits...');
                const response = await createGitHubRequest(`${GITHUB_API_BASE}/commits?per_page=1`);
                
                if (!response.ok) {
                    console.warn('‚ö†Ô∏è Failed to check for new commits:', response.status);
                    return;
                }
                
                const commits = await response.json();
                if (commits.length === 0) return;
                
                const latestCommitSha = commits[0].sha;
                
                if (lastCommitSha === null) {
                    // First check, just store the SHA
                    lastCommitSha = latestCommitSha;
                    console.log('üìù Initial commit SHA stored:', latestCommitSha.substring(0, 8));
                    return;
                }
                
                if (latestCommitSha !== lastCommitSha) {
                    console.log('üÜï New commit detected!', {
                        old: lastCommitSha.substring(0, 8),
                        new: latestCommitSha.substring(0, 8),
                        message: commits[0].commit.message.substring(0, 50) + '...'
                    });
                    
                    lastCommitSha = latestCommitSha;
                    
                    // Update recent files
                    await updateRecentFilesFromNewCommits();
                    
                    // Show notification
                    showNotification('üÜï New commit detected! Recent files updated.', 'success');
                    
                    // If on welcome screen, refresh the recent files display
                    const contentBody = document.getElementById('contentBody');
                    if (contentBody && contentBody.innerHTML.includes('welcome-content')) {
                        console.log('üè† On welcome screen, refreshing recent files...');
                        generateRecentUpdatesList();
                    }
                }
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Error checking for new commits:', error);
            }
        }
        
        async function updateRecentFilesFromNewCommits() {
            try {
                console.log('üîÑ Updating recent files from new commits...');
                const recentCommitFiles = await fetchRecentCommits();
                
                if (recentCommitFiles && recentCommitFiles.length > 0) {
                    await updateRecentFilesFromCommits(recentCommitFiles);
                    console.log('‚úÖ Recent files updated with new commits');
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to update recent files:', error);
            }
        }
        
        // GitHub token management
        function updateGitHubToken() {
            const hasToken = !!localStorage.getItem('github-token');
            const message = hasToken ? 
                'Current token is active.\n\nEnter new token to update, or type "remove" to delete:' :
                'Enter your GitHub Personal Access Token (optional but recommended):\n\n‚Ä¢ Increases rate limit from 60 to 5,000 requests/hour\n‚Ä¢ Enables 2-minute update checks instead of 10-minute\n‚Ä¢ Better performance for real-time updates';
                
            const token = prompt(message);
            
            if (token === null) return; // User cancelled
            
            if (token.toLowerCase() === 'remove') {
                removeGitHubToken();
                return;
            }
            
            if (token.trim()) {
                localStorage.setItem('github-token', token.trim());
                showNotification('‚úÖ GitHub token saved! Rate limit increased to 5,000/hour', 'success');
                updateTokenIcon();
                // Restart updates with new token
                startRealtimeUpdates();
            }
        }
        
        function removeGitHubToken() {
            localStorage.removeItem('github-token');
            showNotification('üóëÔ∏è GitHub token removed. Using anonymous access (60 requests/hour)', 'info');
            // Restart updates without token
            startRealtimeUpdates();
        }
        
        function showTokenStatus() {
            const hasToken = !!localStorage.getItem('github-token');
            const status = hasToken ? 
                '‚úÖ GitHub token configured\n‚Ä¢ Rate limit: 5,000 requests/hour\n‚Ä¢ Update frequency: Every 2 minutes\n\nClick üîë to update token or type "remove" to delete current token' :
                '‚ö†Ô∏è No GitHub token\n‚Ä¢ Rate limit: 60 requests/hour\n‚Ä¢ Update frequency: Every 10 minutes\n\nRecommended: Click üîë to add a token for better performance';
            
            alert(status);
        }
        
        function updateTokenIcon() {
            const hasToken = !!localStorage.getItem('github-token');
            const tokenIcon = document.getElementById('tokenIcon');
            if (tokenIcon) {
                tokenIcon.textContent = hasToken ? '‚úÖ' : '‚ö†Ô∏è';
                tokenIcon.parentElement.title = hasToken ? 
                    'GitHub token active (5,000 req/hour, 2min updates)' : 
                    'No GitHub token (60 req/hour, 10min updates)';
            }
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            initializeTheme();
            initializeApp();
            handleHashNavigation();
            
            // Start real-time updates after app initialization
            setTimeout(() => {
                startRealtimeUpdates();
            }, 5000); // Wait 5 seconds for app to fully load
        });

        // Handle browser back/forward buttons
        window.addEventListener('popstate', () => {
            handleHashNavigation();
        });

        // Handle responsive sidebar
        window.addEventListener('resize', () => {
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.getElementById('mainContent');
            
            if (window.innerWidth > 768) {
                sidebar.classList.remove('open');
                mainContent.classList.remove('sidebar-collapsed');
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 'k':
                        e.preventDefault();
                        document.querySelector('.search-input').focus();
                        break;
                    case 'd':
                        e.preventDefault();
                        toggleTheme();
                        break;
                }
            }
            
            // PDF navigation shortcuts
            if (currentPdf && !e.ctrlKey && !e.metaKey && !e.altKey) {
                switch (e.key) {
                    case 'ArrowLeft':
                    case 'ArrowUp':
                        e.preventDefault();
                        previousPage();
                        break;
                    case 'ArrowRight':
                    case 'ArrowDown':
                    case ' ':
                        e.preventDefault();
                        nextPage();
                        break;
                    case '+':
                    case '=':
                        e.preventDefault();
                        zoomIn();
                        break;
                    case '-':
                        e.preventDefault();
                        zoomOut();
                        break;
                }
            }
            
            if (e.key === 'Escape') {
                hideSearchResults();
            }
        });
    </script>
</body>
</html>